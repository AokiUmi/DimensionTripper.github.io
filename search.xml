<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Luogu P1120 小木棍【数据加强版】</title>
      <link href="/2018/07/24/Luogu%20P1120%20%E5%B0%8F%E6%9C%A8%E6%A3%8D%E3%80%90%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91/"/>
      <url>/2018/07/24/Luogu%20P1120%20%E5%B0%8F%E6%9C%A8%E6%A3%8D%E3%80%90%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91/</url>
      <content type="html"><![CDATA[<p>暴力搜索+剪枝</p><p>（这题简直神级剪枝）</p><p>由于200~1000ms实在坑人（实际上最后T的几乎都是500和1000的数据）</p><p>所以卡了我很久……</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int n,len[N],l,cnt,sum;bool used[N];bool mmp(int x,int y){    return x&gt;y;}void dfs(int x,int y,int lent,int goal,int now)//记录当前的这根小木棍{    if(x&gt;sum/goal)    {        printf(&quot;%d&quot;,goal);        exit(0);    }    if(goal-lent&lt;len[cnt])        return;//如果连最小的填进去都会大于当前答案的话就回溯    for(int i=now;i&lt;=cnt;i++)//从当前开始枚举，因为前面的一定被枚举过了，再做就是浪费时间    {        if(!used[i]&amp;&amp;lent+len[i]&lt;=goal)        {            used[i]=true;            lent+=len[i];            if(lent==goal)                dfs(x+1,1,0,goal,1);            else                dfs(x,y+1,lent,goal,i+1);            used[i]=false;            lent-=len[i];            if(lent+len[i]==goal||lent==0)                break;//如果这一组可以凑出却不是正确答案或者第一根都无法满足就直接退出，没必要再去枚举更小的来代替它，因为这一根总是要被用的。            while(len[i]==len[i+1])                i++;//该长度若不可行，则同样长度的也不可行        }    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;l);        if(l&gt;50)            continue;//一定要优先过滤50+的数据        len[++cnt]=l;        sum+=len[cnt];    }    sort(len+1,len+1+cnt,mmp);//从大到小排序，方便搜索与剪枝    for(int i=len[1];i&lt;=sum/2;i++)        if(sum%i==0)            dfs(1,1,0,i,1);//从小到大枚举答案，遇到一个可直接跳出    printf(&quot;%d&quot;,sum);    return 0;}</code></pre><p>参考了许多题解大佬，从9分到21分到33分到36分到63分到66分到AC……</p><p>而且跑的很慢QwQ</p><p><a href="https://www.luogu.org/record/show?rid=5402366" target="_blank" rel="noopener">1100ms</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1278 单词游戏</title>
      <link href="/2018/07/24/Luogu%20P1278%20%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/07/24/Luogu%20P1278%20%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>这道题<del>据说</del>正解是dp……</p><p>然而我不会……</p><p>所以就写成一个裸的dfs，然后理所当然的T了</p><p><a href="https://www.luogu.org/record/show?rid=5334291" target="_blank" rel="noopener">A7T3</a></p><p>接着就被旁边的dalao嘲笑了</p><p>DTZ大佬的记录</p><p><a href="https://www.luogu.org/record/show?rid=5333743" target="_blank" rel="noopener">0ms</a></p><p>于是我想到了卡时（懒得改记忆化）</p><p>结果莫名就A了……</p><p>具体看代码</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define N 200using namespace std;char s[N/10][N];int a[N/10][N],n,sum,ans,f[N],tim;bool used[N/10],flag;bool check(char x,int y){    if(x==s[y][0]||x==&#39;\0&#39;)        return true;    return false;}//检查上个单词的最后一位与当前单词的第一位void dfs(int x,char y){    if(clock()-tim&gt;10000)    {        cout&lt;&lt;ans;        exit(0);    }//卡时基本操作，运行到这个时间就输出（虽然听说clock()贼慢，但会省下更多时间）    flag=false;//记录当前点能否搜下去    for(int i=1;i&lt;=n;i++)//枚举当前点    {        if(!used[i]&amp;&amp;check(y,i))        {            flag=true;            int len=strlen(s[i]);            used[i]=true;            sum+=len;            dfs(x+1,s[i][len-1]);//向下搜            sum-=len;            used[i]=false;//回溯        }    }    if(!flag)    {        ans=max(sum,ans);        return;    }//搜不下去就更新答案}int main(){    tim=clock();    scanf(&quot;%d\n&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        if(i!=n)            scanf(&quot;%s\n&quot;,s[i]);        else            scanf(&quot;%s&quot;,s[i]);    }    dfs(1,&#39;\0&#39;);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>这样一看这个也是道假的蓝题……</p><p>卡时有WA的风险，千万别随便学……</p><p>不过这里能A（虽然跑的很慢）</p><p><a href="https://www.luogu.org/record/show?rid=5334979" target="_blank" rel="noopener">136ms</a></p><p>代码有待优化，请各位julao自行修改QwQ。</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
            <tag> 卡时 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1092 虫食算</title>
      <link href="/2018/07/24/Luogu%20P1092%20%E8%99%AB%E9%A3%9F%E7%AE%97/"/>
      <url>/2018/07/24/Luogu%20P1092%20%E8%99%AB%E9%A3%9F%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>由于本人代码不精，连深搜都快忘光了……</p><p>难得写个题，于是来记录一下我的做法。</p><p>首先，这是一道深搜题，但很明显，一个一个字母去搜肯定会炸，怎么办呢？</p><p>我们很容易想到的就是一个一个位置的去搜。</p><p>大家都学过竖式加法，从右往左，从上往下，就按这个顺序一个位置一个位置的搜，很明显就要快一些。</p><p>那么这样就能过了吗？不是，还需要剪枝。</p><p>在这样一个搜索顺序的基础上，搜完一条加一次判定，虽然会用一些时间，但和它省下来的时间比简直不值一提。</p><p>废话不多说，看代码注释</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)//手开O3优化#define N 30using namespace std;bool flag,used[N];int n,a[5][N],num[N];char s[5][N];bool check()//检查是否正确{    int add=0;    for(int i=n;i&gt;=1;i--)    {        int A,B,C;        A=num[a[1][i]],B=num[a[2][i]],C=num[a[3][i]];        if((A+B+add)%n!=C)            return false;        add=(A+B+add)/n;    }    return true;}bool Prune()//剪枝，如果最高位要进位或者无论进不进位都不能使等式成立即舍{    if(num[a[1][1]]+num[a[2][1]]&gt;=n)        return true;    for(int i=n-1;i&gt;=0;i--)    {        int A=num[a[1][i]],B=num[a[2][i]],C=num[a[3][i]];        if(A==-1||B==-1||C==-1)            continue;        if((A+B)%n!=C&amp;&amp;(A+B+1)%n!=C)            return true;    }    return false;}void Print(){    for(int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,num[i]);    return;}bool Check()//检查是否有字母没赋值{    for(int i=1;i&lt;=n;i++)        if(num[i]==-1)            return false;    return true;}void dfs(int x,int y,int t)//x是列，y是行，t是进位{    if(flag)//标记数组，其实可用exit(0)代替        return;    if(Prune())//开局剪枝        return;    if(Check())    {       if(check())        {            Print();            flag=true;        }        return;    }//如果每个字母都赋值了就进行判定，可以省去一些无用的搜索时间    if(num[a[y][x]]==-1)//如果这一位没赋值    {        for(int i=n-1;i&gt;=0;i--)        {            if(!used[i])            {                if(y!=3)//如果不是第三行                {                    num[a[y][x]]=i;                    used[i]=true;                    dfs(x,y+1,t);//搜索同列下一行                    used[i]=false;                    num[a[y][x]]=-1;                }                else//是第三行                {                    int z=num[a[1][x]]+num[a[2][x]]+t;                    if(z%n!=i)                        continue;                    used[i]=true;                    num[a[y][x]]=i;                    dfs(x-1,1,z/n);//搜索下一列第一行，进位改变                    used[i]=false;                    num[a[y][x]]=-1;                }            }        }    }    else//这一位已被赋值    {        if(y!=3)            dfs(x,y+1,t);        else        {            int z=num[a[1][x]]+num[a[2][x]]+t;            if(Prune())//剪个枝                return;            dfs(x-1,1,z/n);        }    }    return;}void Getid()//将字母转换成数字{    for(int i=1;i&lt;=3;i++)        for(int j=0;j&lt;n;j++)            a[i][j+1]=s[i][j]-&#39;A&#39;+1;    return;}int main(){    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%s%s%s&quot;,s[1],s[2],s[3]);    Getid();    memset(num,-1,sizeof(num));//初值设为-1    dfs(n,1,0);//搜索第n列第1行，进位为0    return 0;}</code></pre><p>注：<br>搜索顺序从0到n-1跑的要慢一些，建议学我，从n-1到0去搜</p><p>#从0到n-1</p><p><a href="https://www.luogu.org/record/show?rid=5303961" target="_blank" rel="noopener">844ms</a></p><p>#从n-1到0</p><p><a href="https://www.luogu.org/record/show?rid=5304076" target="_blank" rel="noopener">16ms</a></p><p>其实也就是这样不是</p><p>我的代码还有些地方可以优化，我也懒得改了orz（躺</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1047 校门外的树</title>
      <link href="/2018/07/24/Luogu%20P1047%20%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/"/>
      <url>/2018/07/24/Luogu%20P1047%20%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>首先，如题目算法标签所言，线段树<del>（其实也是杂技写法）</del></p><p>不多赘述，建树、修改、查询一气呵成，就算是杂技，也要做杂技中的豪杰（逃）</p><p>代码如下：</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define N 2000010using namespace std;struct node{    int left,right;    long long val,sum;};struct node a[4*N];int data[N],n,m,x,y,b;long long z;void pushup(int p){    a[p].sum=a[2*p].sum+a[2*p+1].sum;}void pushdown(int p){    if(a[p].val!=-1)    {        a[2*p].val=a[p].val;        a[2*p+1].val=a[p].val;        a[2*p].sum=(a[2*p].right-a[2*p].left+1)*a[p].val;        a[2*p+1].sum=(a[2*p+1].right-a[2*p+1].left+1)*a[p].val;        a[p].val=-1;    }}//pushup、pushdown是基本操作，不多讲void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    a[p].val=-1;    if(l==r)    {        a[p].sum=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    a[p].sum=a[2*p].sum+a[2*p+1].sum;}//建树也很简单long long query(int p,int l,int r){    if(a[p].left==l&amp;&amp;a[p].right==r)        return a[p].sum;    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        return query(2*p,l,r);    else if(l&gt;mid)        return query(2*p+1,l,r);    else        return query(2*p,l,mid)+query(2*p+1,mid+1,r);}//查询void change(int p,int l,int r,long long d){    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].sum=(l-r+1)*d;        a[p].val=0;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        change(2*p,l,r,d);    else if(l&gt;mid)        change(2*p+1,l,r,d);    else    {        change(2*p,l,mid,d);        change(2*p+1,mid+1,r,d);    }    pushup(p);}//此函数是与模板唯一的差别，将砍掉的树的值赋为0，这样就只需查询根节点处的区间和了int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n+1;i++)        data[i]=1;//将每个位置的初值赋为1，方便查询时只查根节点。值得注意的是，由于这里是算了0这个位置的，所以n、x、y都要相应的加1    build(1,1,n+1);    for(int i=1;i&lt;=m;i++)    {        cin&gt;&gt;x&gt;&gt;y;        change(1,x+1,y+1,0);    }    cout&lt;&lt;query(1,1,n+1);    return 0;}</code></pre><p>比较简单不多说，具体注释看代码</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1083 借教室线段树AC</title>
      <link href="/2018/07/18/Luogu%20P1083%20%E5%80%9F%E6%95%99%E5%AE%A4%E7%BA%BF%E6%AE%B5%E6%A0%91AC/"/>
      <url>/2018/07/18/Luogu%20P1083%20%E5%80%9F%E6%95%99%E5%AE%A4%E7%BA%BF%E6%AE%B5%E6%A0%91AC/</url>
      <content type="html"><![CDATA[<p>首先我们说这道题是线段树<del>（其实只是不会二分而已）</del><br>既然是线段树，那么我们首先当然是最简单的建树<br>建树代码如下</p><pre><code class="cpp">void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    if(l==r)    {        a[p].num=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    pushup(p);}</code></pre><p>此处只需要查询区间最小值，所以建树是很基础的，就不多赘述了。<br>接下来是更新</p><pre><code class="cpp">void add(int p,int l,int r,long long d){    if(f==1)        return;    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].val+=d;        a[p].num+=d;        if(a[p].num&lt;0)            f=1;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        add(2*p,l,r,d);    else if(l&gt;mid)        add(2*p+1,l,r,d);    else    {        add(2*p,l,mid,d);        add(2*p+1,mid+1,r,d);    }    pushup(p);}</code></pre><p>值得注意的是此处的标记是为了优化，如果不加就会T掉一个点<br>最后查询的时候只需查询根节点的区间最小值，只需查标记就可以了（但是先要更新）<br>总代码如下：</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;struct node{    int left,right;    long long val,num;};struct node a[4*N];int data[N],n,m,x,y,z,b,f;void pushup(int p){    a[p].num=min(a[2*p].num,a[2*p+1].num);}void pushdown(int p){    if(a[p].val!=0)    {        a[2*p].val+=a[p].val;        a[2*p+1].val+=a[p].val;        a[2*p].num+=a[p].val;        a[2*p+1].num+=a[p].val;        a[p].val=0;    }}void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    if(l==r)    {        a[p].num=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    pushup(p);}void add(int p,int l,int r,long long d){    if(f==1)        return;    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].val+=d;        a[p].num+=d;        if(a[p].num&lt;0)            f=1;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        add(2*p,l,r,d);    else if(l&gt;mid)        add(2*p+1,l,r,d);    else    {        add(2*p,l,mid,d);        add(2*p+1,mid+1,r,d);    }    pushup(p);}int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;data[i]);    build(1,1,n);    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);        add(1,y,z,-x);        if(f==1)        {            printf(&quot;-1\n%d&quot;,i);            return 0;        }    }    printf(&quot;0&quot;);    return 0;}</code></pre><p>虽然说是卡线段树，但其实并不会（虽然3448ms跑的比较慢）<br>总还是可以A</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解 Luogu P1205 【[USACO1.2]方块转换 Transformations】</title>
      <link href="/2018/07/18/Luogu%20P1205%20%E3%80%90%5BUSACO1.2%5D%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2%20Transformations%E3%80%91/"/>
      <url>/2018/07/18/Luogu%20P1205%20%E3%80%90%5BUSACO1.2%5D%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2%20Transformations%E3%80%91/</url>
      <content type="html"><![CDATA[<p>事先说明，发这种代码没有别的意思，纯属好玩<br>这种方法，是谁都会的……暴力……<br>看下来是要有一定毅力的，请谨慎选择是否浏览接下来的代码。</p><pre><code class="cpp">#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define N 10000000+110using namespace std;int flag,f,g,h,x,y,p,z;int main(){    char a[100][100],b[100][100],c[100][100],d[100][100],e[100][100],w[100][100],r[100][100],t[100][100];    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            cin&gt;&gt;a[i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            cin&gt;&gt;d[i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=a[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                flag=1;                break;            }    if(flag==0)    {        cout&lt;&lt;1;        return 0;    }//顺时针旋转90度    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            e[i][j]=a[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            w[i][j]=e[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(w[i][j]!=d[i][j])            {                f=1;                break;            }    if(f==0&amp;&amp;flag==1)    {        cout&lt;&lt;3;        return 0;    }//顺时针旋转180度（因为当时复制错了所以先3再2）    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            r[i][j]=a[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=r[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(t[i][j]!=d[i][j])            {                g=1;                break;            }    if(g==0&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;2;        return 0;    }//逆时针旋转90度    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(t[i][j]!=d[i][j])            {                x=1;                break;            }    if(x==0&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;4;        return 0;    }//镜像翻转    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                y=1;                break;            }    if(y==0&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//5里面分3种情况，4+1，4+2，4+3，此板块接下来的两个板块分别模拟了这三种情况（都看得懂就不详细说明了）    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                z=1;                break;            }    if(z==0&amp;&amp;y==1&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//第二种    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                p=1;                break;            }    if(p==0&amp;&amp;z==1&amp;&amp;y==1&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//第三种    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(a[i][j]!=d[i][j])            {                h=1;                break;            }    if(h==0&amp;&amp;x==1&amp;&amp;y==1&amp;&amp;z==1&amp;&amp;p==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;6;        return 0;    }//无变换    if(h==1&amp;&amp;x==1&amp;&amp;y==1&amp;&amp;z==1&amp;&amp;p==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)        cout&lt;&lt;7;//其他    return 0;}</code></pre><p>此题理论上来讲不能随便调换判断的顺序，比如我最初优先判断较为简单的6，结果不能输出最小值……<br>这里调换了2和3，是因为不存在顺时针转90度不可行，而顺时针转180度和逆时针转90度同时可行的情况。<br>所以说这是暴力解法，是谁都会的，只要你有耐心、有毅力，都能做得出来，没什么参考价值【滑稽】</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>可读性极差的A+B</title>
      <link href="/2018/07/18/%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9E%81%E5%B7%AE%E7%9A%84A+B/"/>
      <url>/2018/07/18/%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9E%81%E5%B7%AE%E7%9A%84A+B/</url>
      <content type="html"><![CDATA[<p>请谨慎选择是否阅读QwQ</p><pre><code class="cpp">#include &lt;bits/stdc++.h&gt;#define ________ return 0#define _____ cin&gt;&gt;#define __________ cout&lt;&lt;#define __ &gt;&gt;#define _ +#define ___ int#define ______ main()using namespace std;___ _________,___________;___ ______{    _____ _________ __ ___________;    __________ _________ _ ___________;    ________;}</code></pre>]]></content>
      
      <categories>
          
          <category> 瞎jb搞 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>博客建成祭</title>
      <link href="/2018/07/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E7%A5%AD/"/>
      <url>/2018/07/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E7%A5%AD/</url>
      <content type="html"><![CDATA[<p>博客搭建成功啦，纪念一波QwQ</p>]]></content>
      
      <categories>
          
          <category> 祭 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
