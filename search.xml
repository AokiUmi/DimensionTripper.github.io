<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>二分图匹配</title>
      <link href="/2018/07/24/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/07/24/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>如题所述，这类问题让我们求一个二分图的最大匹配，不知道二分图的同学请参考<a href="https://baike.baidu.com/item/二分图/9089095?fr=aladdin" target="_blank" rel="noopener">百度百科</a></p><p>看着那些术语让人头大对吧，那么来通俗一点的：给定若干个男生和若干个女生，每个男生都可以和一定数量的女生互相有好感，假定不存在同性恋和后宫，求最多能凑多少对CP<del>（然后再统统烧了）</del>。</p><p>对于这类问题通常有两种做法：匈牙利和网络流。</p><h1 id="匈牙利算法"><a href="#匈牙利算法" class="headerlink" title="匈牙利算法"></a>匈牙利算法</h1><p>在我讲之前，我建议读者先去读一下Dark_Scope的这篇<a href="https://blog.csdn.net/dark_scope/article/details/8880547" target="_blank" rel="noopener">趣写算法系列之—匈牙利算法</a>，相当的简单易懂。</p><p>那么我来用正经的话把他（她？）的语言翻译一遍：对于点集M中的每一个点u，找到与它配对的点v，如果点v尚未配对就把u、v配对，否则就试图给v的“原配”寻找新的配对点，找到后就把u、v配对。实际就是一个寻找增广路的过程。</p><p>相信有这些已经够清楚的了，以下是代码：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500000+110using namespace std;int n,m,s,cnt,ans;int head[N],q[N],pre[N],mate[N];bool vis[N];struct edge{    int to,nxt;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline int add(int u,int v){    e[++cnt]=(edge){v,head[u]};    head[u]=cnt;}inline bool Find(int u){    for(register int i=head[u];i;i=e[i].nxt)    {        int v=e[i].to;        if(!vis[v])        {            vis[v]=1;            if(!mate[v]||Find(mate[v]))            {                mate[v]=u;                return 1;            }        }    }    return 0;}int main(){    n=read(),m=read(),s=read();    for(register int i=1;i&lt;=s;i++)    {        int u=read(),v=read();        if(v&gt;m||u&gt;n)            continue;        add(u,v);    }    for(register int i=1;i&lt;=n;i++)    {        memset(vis,0,sizeof(vis));        if(Find(i))            ans++;    }    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><h1 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h1><p>很容易想到如果额外增加一个源点和一个汇点，然后就可以直接跑网络最大流了。</p><p>对于无权图，我们需要设置边权，很容易想到正向边为1，反向边为0，这样就可以很顺利的用Dinic跑出最大匹配了。</p><p>可以看出比匈牙利快多了<del>（虽然没有( min(a,b)-1 )算法快）</del></p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define ri register int#define il inline#define ll long longusing namespace std;const int N=2000000+110;const int inf=0x7fffffff;const int MAXN=50;const double eps=1e-8;il int read(){    int x=0,f=1;    char ch=getchar();    while(!isdigit(ch))    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(isdigit(ch))    {        x=(x&lt;&lt;3)+(x&lt;&lt;1)+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}int n,m,k,cnt;int head[N],q[N],dep[N],cur[N];struct edge{    int to,nxt,weight;};edge e[N];il void add_edge(int u,int v,int w){    e[cnt]=(edge){v,head[u],w};    head[u]=cnt++;}il bool BFS(int S,int T){    int fr=1,tl=0;    memset(dep,0,sizeof(dep));    dep[S]=1;    q[1]=S;    while(tl&lt;fr)    {        int u=q[++tl];        for(ri i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(!dep[v]&amp;&amp;e[i].weight&gt;0)            {                dep[v]=dep[u]+1;                q[++fr]=v;            }        }    }    if(!dep[T])        return 0;    return 1;}il int dfs(int u,int t,int flow){    if(u==t)        return flow;    for(ri&amp; i=cur[u];i!=-1;i=e[i].nxt)    {        int v=e[i].to;        if(dep[v]==dep[u]+1&amp;&amp;e[i].weight&gt;0)        {            int dis=dfs(v,t,min(flow,e[i].weight));            if(dis&gt;0)            {                e[i].weight-=dis;                e[i^1].weight+=dis;                return dis;            }        }    }    return 0;}il int Dinic(int S,int T){    int ret=0;    while(BFS(S,T))    {        for(ri i=0;i&lt;=n+m+1;i++)            cur[i]=head[i];        while(int delta=dfs(S,T,inf))            ret+=delta;    }    return ret;}int main(){    n=read(),m=read(),k=read();    memset(head,-1,sizeof(head));    for(ri i=1;i&lt;=k;i++)    {        int u=read(),v=read();        if(v&gt;m)            continue;        add_edge(u,n+v,1);        add_edge(n+v,u,0);    }    for(ri i=1;i&lt;=n;i++)    {        add_edge(0,i,1);        add_edge(i,0,0);    }    for(ri i=1;i&lt;=m;i++)    {        add_edge(n+i,n+m+1,1);        add_edge(n+m+1,n+i,0);    }    printf(&quot;%d&quot;,Dinic(0,n+m+1));    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>【胡扯向】数据生成器</title>
      <link href="/2018/07/24/%E3%80%90%E8%83%A1%E6%89%AF%E5%90%91%E3%80%91%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8/"/>
      <url>/2018/07/24/%E3%80%90%E8%83%A1%E6%89%AF%E5%90%91%E3%80%91%E6%95%B0%E6%8D%AE%E7%94%9F%E6%88%90%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>作为一名OIER，我们会时不时的需要生成几组比较大的数据来进行测试，但是这种东西手玩肯定是不可能实现的，所以就需要用到数据生成器了。</p><p>这种东西呢，大家都知道是基于rand函数随机生成的数据，由于笔者极其的蒟蒻，所以决定先从比较基础的数据结构讲起。</p><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>首先因为基础的大家都会，这里就不讲了，从全排列开始吧。</p><p>当然比较暴力的做法是多次rand，对每个数打标，如果rand到打了标的数就重做，直到生成全排列为止，但面对$10^6$甚至更大的数据的时候这样就基本不可能输出了。</p><p>所以我们根据抽牌的原理写出了以下这段程序：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000000+110using namespace std;int n,a[N];int main(){    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);    srand((unsigned)time(NULL));    n=1+rand()%1000000;    printf(&quot;%d\n&quot;,n);    for(register int i=1;i&lt;=n;i++)        a[i]=i;    for(register int i=1;i&lt;=n;i++)    {        int x=1+rand()%(n-i+1);        printf(&quot;%d &quot;,a[x]);        swap(a[x],a[n-i+1]);    }    return 0;}</code></pre><p>在上面这个程序中，我们每次在前(n-i+1)个数中抽一个出来，然后把它换到第(n-i+1)个位置上，这样就可以保证相对快速而且不重复。</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>对于树，而且是比较规矩的，画出来真正有树的形状的树，我们也可以用类似的思想生成。</p><p>在这里，我们把所有用过的点放在后i个位置，每次从未用过的点中随机取出一个点v，从用过的点中随机取出一个点u，就相当于生成了一条由u到v的边，然后将v点放入已使用点集。</p><p>代码如下：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000000+110using namespace std;int n,a[N];int main(){    freopen(&quot;data.out&quot;,&quot;w&quot;,stdout);    srand((unsigned)time(NULL));    n=1+rand()%1000000;    printf(&quot;%d\n&quot;,n);    for(register int i=1;i&lt;=n;i++)        a[i]=i;    swap(a[1],a[n]);    for(register int i=1;i&lt;n;i++)    {        int v=1+rand()%(n-i),u=n-i+1+rand()%i;        printf(&quot;%d %d\n&quot;,a[u],a[v]);        swap(a[v],a[n-i]);    }    return 0;}</code></pre><p>这样就可以得到一棵树了。</p>]]></content>
      
      <categories>
          
          <category> 瞎jb搞 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据生成器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>费用流</title>
      <link href="/2018/07/24/%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
      <url>/2018/07/24/%E8%B4%B9%E7%94%A8%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>费用流，就是在网络流的基础上加入了每条边单位流量的费用，求最大流量和在最大流量的情况下费用的最小值的问题。</p><p>对于这种问题，基本思路当然还是在最大流问题的基础上修改啊</p><p>所以在这里我给出2种解法：（例题：<a href="https://www.luogu.org/problemnew/show/P3381" target="_blank" rel="noopener"> P3381 【模板】最小费用最大流</a>）</p><h1 id="1、EK-改"><a href="#1、EK-改" class="headerlink" title="1、EK-改"></a>1、EK-改</h1><p>当然这也是目前的主流写法，在EK中，将BFS过程换成SPFA的过程，松弛与增广一起进行，当然是很美妙的写法。当然整体的代码和EK没有什么特别大的区别，就不多讲了。</p><p>下面是代码（1604ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110#define inf 0x7fffffffusing namespace std;int n,m,S,T,cnt,ans,Ans;int head[N],q[N],pre[N],dist[N],mn[N];bool vis[N];struct edge{    int to,nxt,weigh,cost;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline int add(int u,int v,int w,int f){    e[cnt]=(edge){v,head[u],w,f};    head[u]=cnt++;}inline bool SPFA(int s,int t){    for(register int i=1;i&lt;=n;i++)        dist[i]=inf,vis[i]=0,pre[i]=-1;    int fr=1,tl=0;    q[1]=s,vis[s]=1,mn[s]=inf,dist[s]=0;    while(tl&lt;fr)    {        int u=q[++tl];        vis[u]=0;        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(dist[v]&gt;dist[u]+e[i].cost&amp;&amp;e[i].weigh&gt;0)            {                dist[v]=dist[u]+e[i].cost;                mn[v]=min(e[i].weigh,mn[u]);                pre[v]=i;                if(!vis[v])                {                    q[++fr]=v;                    vis[v]=1;                }            }        }    }    return dist[t]!=inf;}inline void EK(int s,int t){    while(SPFA(s,t))    {        int x=t;        while(x!=s)        {            int i=pre[x];            e[i].weigh-=mn[t];            e[i^1].weigh+=mn[t];            x=e[i^1].to;        }        Ans+=mn[t];        ans+=dist[t]*mn[t];    }}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read(),f=read();        add(u,v,w,f);        add(v,u,0,-f);    }    EK(S,T);    printf(&quot;%d %d&quot;,Ans,ans);    return 0;}</code></pre><h1 id="2、ZKW"><a href="#2、ZKW" class="headerlink" title="2、ZKW"></a>2、ZKW</h1><p>首先%ZKW大神：<a href="https://artofproblemsolving.com/community/c1368h1020435" target="_blank" rel="noopener">从入门到精通: 最小费用流的“zkw算法”</a></p><p>是不是觉得EK实在是慢得惊人呢？那么我们来看一下ZKW神犇发明的“ZKW算法”。当然，按照ZKW本人的意思，我下面贴的这段代码并不是“ZKW费用流”，因为它用到了SPFA。ZKW本人的代码可以在上面的链接里找到，以下是我个人的见解（因为我不会KM啊）</p><p>这里呢，我们用了一个DFS，它的用处就在于多路增广，可以降低某些图上的复杂度。有这个基础的话就可以接受SPFA的复杂度了，而且也可以在有负权的图上跑了。</p><p>以下是代码（932ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110#define inf 0x7fffffffusing namespace std;int n,m,S,T,cnt,ans;int deep[N],head[N],q[N],dist[N];bool vis[N];struct edge{    int to,nxt,weigh,cost;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w,int f){    e[cnt]=(edge){v,head[u],w,f};    head[u]=cnt++;}inline bool SPFA(int s,int t){    for(register int i=1;i&lt;=n;i++)        dist[i]=inf,vis[i]=0;    dist[t]=0;    vis[t]=1;    //首先SPFA我们维护距离标号的时候要倒着跑，这样可以维护出到终点的最短路径    int fr=1,tl=0;    q[1]=t;    while(tl&lt;fr)    {        int u=q[++tl];        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(e[i^1].weigh&amp;&amp;dist[v]&gt;dist[u]-e[i].cost)//首先c[k^1]是为什么呢？因为我们要保证正流，但是SPFA是倒着跑的，所以说我们要求c[k]的对应反向边是正的，这样保证走的方向是正确的            {                dist[v]=dist[u]-e[i].cost;//因为已经是倒着的了，我们也可以很清楚明白地知道建边的时候反向边的边权是负的，所以减一下就对了（负负得正）                if(!vis[v])                {                    vis[v]=1;                    q[++fr]=v;                }            }        }        vis[u]=0;    }    return dist[s]&lt;inf}inline int dfs(int u,int t,int dis){    if(u==t)    {        vis[t]=1;        return dis;    }    vis[u]=1;    int used=0;    for(register int i=head[u];i!=-1;i=e[i].nxt)    {        int v=e[i].to;        if(!vis[v]&amp;&amp;e[i].weigh&amp;&amp;dist[u]-e[i].cost==dist[v])//增广的条件（虽然我不太懂）        {            int a=dfs(v,t,min(e[i].weigh,dis-used));            if(a)            {                ans+=a*e[i].cost;                e[i].weigh-=a;                e[i^1].weigh+=a;                used+=a;            }            if(used==dis)                break;        }    }    return used;}inline int CostFlow(int s,int t){    int flow=0;    while(SPFA(s,t))    {        vis[t]=1;        while(vis[t])        {            for(register int i=1;i&lt;=n;i++)                vis[i]=0;            flow+=dfs(s,t,inf);        }    }    return flow;}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read(),f=read();        add(u,v,w,f);        add(v,u,0,-f);    }    printf(&quot;%d &quot;,CostFlow(S,T));    printf(&quot;%d&quot;,ans);;    return 0;}</code></pre><p>以上就是一般的ZKW（伪）</p><h2 id="SLF优化"><a href="#SLF优化" class="headerlink" title="SLF优化"></a>SLF优化</h2><p>那么如果对这个效率还不满意呢？</p><p>对了，向标题所说的那样，进行SLF优化吧（虽然我不懂）</p><p>代码如下（860ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110#define inf 0x7fffffffusing namespace std;int n,m,S,T,cnt,ans;int deep[N],head[N],dist[N];bool vis[N];struct edge{    int to,nxt,weigh,cost;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w,int f){    e[cnt]=(edge){v,head[u],w,f};    head[u]=cnt++;}inline bool SPFA(int s,int t){    for(register int i=1;i&lt;=n;i++)        dist[i]=inf,vis[i]=0;    dist[t]=0;    vis[t]=1;    deque&lt;int&gt;q;    q.push_back(t);    while(!q.empty())    {        int u=q.front();        q.pop_front();        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(e[i^1].weigh&amp;&amp;dist[v]&gt;dist[u]-e[i].cost)            {                dist[v]=dist[u]-e[i].cost;                if(!vis[v])                {                    vis[v]=1;                    if(!q.empty()&amp;&amp;dist[v]&lt;dist[q.front()])                        q.push_front(v);                    else                        q.push_back(v);                }            }        }        vis[u]=0;    }    if(dist[s]&lt;inf)        return 1;    else        return 0;}inline int dfs(int u,int t,int dis){    if(u==t)    {        vis[t]=1;        return dis;    }    vis[u]=1;    int used=0;    for(register int i=head[u];i!=-1;i=e[i].nxt)    {        int v=e[i].to;        if(!vis[v]&amp;&amp;e[i].weigh&amp;&amp;dist[u]-e[i].cost==dist[v])        {            int a=dfs(v,t,min(e[i].weigh,dis-used));            if(a)            {                ans+=a*e[i].cost;                e[i].weigh-=a;                e[i^1].weigh+=a;                used+=a;            }            if(used==dis)                break;        }    }    return used;}inline int CostFlow(int s,int t){    int flow=0;    while(SPFA(s,t))    {        vis[t]=1;        while(vis[t])        {            for(register int i=1;i&lt;=n;i++)                vis[i]=0;            flow+=dfs(s,t,inf);        }    }    return flow;}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read(),f=read();        add(u,v,w,f);        add(v,u,0,-f);    }    printf(&quot;%d &quot;,CostFlow(S,T));    printf(&quot;%d&quot;,ans);;    return 0;}</code></pre><p>看完代码和上面的一比较，你们大概会觉得没什么区别吧，说起来也差不多，就是SPFA的时候用了个双端队列的STL，然后入队时加入了一点玄学特判，总之就是这样了，反正这样就快一些就是了。</p><p>【注】本段部分引用<a href="https://blog.csdn.net/jzq233jzq/article/details/73123089" target="_blank" rel="noopener">一种更高效的费用流算法——zkw费用流</a></p><hr><p>然后费用流就讲完了DA☆ZE！</p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最短路</title>
      <link href="/2018/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
      <url>/2018/07/24/%E6%9C%80%E7%9F%AD%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>如标题所示，这一类的算法就是为了解决这一类的单源最短路径问题。</p><p>所谓的单源最短路径问题呢，就是指在一个有向图中，给定点S，要求从S点出发遍历全图的最短路径。</p><p>例题：<a href="https://www.luogu.org/problemnew/show/P3371#sub" target="_blank" rel="noopener">P3371 【模板】单源最短路径</a></p><p>以下我来讲几种算法（如果有可能的话）</p><h1 id="1、SPFA"><a href="#1、SPFA" class="headerlink" title="1、SPFA"></a>1、SPFA</h1><p>它被誉为“最快最好用的最短路算法”，<del>但是被各种心狠手辣的出题人卡成了狗</del>自有其优越性，毕竟像笔者这种蒟蒻都看了一遍就懂了。</p><p>SPFA用了一种动态逼近的方法，设立一个先进先出的队列q来保存待优化的节点，每次取出队首的节点u，并用u点当前的最短路径的估计值对离开u指向的v节点进行松弛操作，如果v点的最短路径估计值有所调整，并且v不在当前队列中，就把它放入队列中如此不断从队列中取出节点进行松弛操作，直至队列空为止。</p><p>那么说到松弛操作，原理就是十分著名的三角不等式，即我们数学中都用过的“两边之和大于第三边”，也就是v当前的最短路径估算值大于u当前的最短路径估算值与边[u,v]的长度之和，那么就更新v最短路径的估算值，也就是这样：</p><pre><code class="lang-cpp">if(dist[v]&gt;dist[u]+e[i].weigh)    dist[v]=dist[u]+e[i].weigh;</code></pre><p>当然，实际的代码中还要加上进队的操作。</p><p>当然你也许会说，这个怎么这么像BFS呢？其实还真有点，区别就在于BFS中一个点不能重复进队，而这里是可以反复松弛的。</p><h3 id="切记：每次取出队首节点的时候一定要清空标记！！"><a href="#切记：每次取出队首节点的时候一定要清空标记！！" class="headerlink" title="切记：每次取出队首节点的时候一定要清空标记！！"></a>切记：每次取出队首节点的时候一定要清空标记！！</h3><p>那么在贴代码之前，先来手玩一下样例。样例图如下：</p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/QzGubFdwvbb*zKqW6BSSa2aeEGzCTK0gQXF4f9iTYno!/c/dCEBAAAAAAAA&amp;bo=WgHzAFoB8wABACc!" alt=""></p><p>过程如下：</p><h3 id="q-1"><a href="#q-1" class="headerlink" title="q:1"></a>q:1</h3><h3 id="dis-0-inf-inf-inf"><a href="#dis-0-inf-inf-inf" class="headerlink" title="dis:0,inf,inf,inf"></a>dis:0,inf,inf,inf</h3><p>源点1进队，更新最短距离</p><h3 id="q-2-3-4"><a href="#q-2-3-4" class="headerlink" title="q:2,3,4"></a>q:2,3,4</h3><h3 id="dis-0-2-5-4"><a href="#dis-0-2-5-4" class="headerlink" title="dis:0,2,5,4"></a>dis:0,2,5,4</h3><p>1出队，2、3、4进队，2&lt;inf，5&lt;inf，4&lt;inf，更新2、3、4的最短路径</p><h3 id="q-3-4"><a href="#q-3-4" class="headerlink" title="q:3,4"></a>q:3,4</h3><h3 id="dis-0-2-4-3"><a href="#dis-0-2-4-3" class="headerlink" title="dis:0,2,4,3"></a>dis:0,2,4,3</h3><p>2出队，5&gt;2+2，4&gt;2+1，更新3、4的最短路径</p><h3 id="q-4"><a href="#q-4" class="headerlink" title="q:4"></a>q:4</h3><h3 id="dis-0-2-4-3-1"><a href="#dis-0-2-4-3-1" class="headerlink" title="dis:0,2,4,3"></a>dis:0,2,4,3</h3><p>3出队</p><h3 id="q"><a href="#q" class="headerlink" title="q:"></a>q:</h3><h3 id="dis-0-2-4-3-2"><a href="#dis-0-2-4-3-2" class="headerlink" title="dis:0,2,4,3"></a>dis:0,2,4,3</h3><p>4出队，队列已空，此时已找到最短路径</p><p>以下是代码：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000000+110#define inf 0x7fffffffusing namespace std;int n,m,S,cnt;int dist[N],head[N],q[N];bool vis[N];struct edge{    int to,nxt,weigh;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w){    e[++cnt]=(edge){v,head[u],w};    head[u]=cnt;}inline void SPFA(int s){    int fr=1,tl=0;    for(int i=1;i&lt;=n;i++)        dist[i]=inf,vis[i]=0;    dist[s]=0;    q[1]=s;    vis[s]=1;    while(tl&lt;fr)    {        int u=q[++tl];        vis[u]=0;        for(register int i=head[u];i;i=e[i].nxt)        {            int v=e[i].to;            if(dist[v]&gt;dist[u]+e[i].weigh)            {                dist[v]=dist[u]+e[i].weigh;                if(!vis[v])                {                    q[++fr]=v;                    vis[v]=1;                }            }        }    }}int main(){    n=read(),m=read(),S=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read();        add(u,v,w);    }    SPFA(S);    for(register int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,dist[i]);    return 0;}</code></pre><p>虽然这样写基本正确，但如果面对这样一个图，SPFA就很绝望了：</p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/ndvqtccKCoyRQveb9Xfz8RpBPNFaWOyO5ZbNSM4HsDM!/c/dCEBAAAAAAAA&amp;bo=ZgI5AWYCOQEBACc!" alt=""></p><p>可以看到，1、2、4三点间形成了一个负环，也就是说这几个点间没有所谓的最短路，因此就会无限的跑下去。</p><p>那么怎么办呢？我们可以对每个点入队的次数进行限制，如果超过所有点的总数，那么就可以判断出现了负环，就跳出函数。</p><p>代码也没有太大的区别：</p><pre><code class="lang-cpp">inline void SPFA(int s){    int fr=1,tl=0;    for(int i=1;i&lt;=n;i++)        dist[i]=inf,vis[i]=0,c[i]=0;    dist[s]=0;    q[1]=s;    vis[s]=1;    while(tl&lt;fr)    {        int u=q[++tl];        vis[u]=0;        for(register int i=head[u];i;i=e[i].nxt)        {            int v=e[i].to;            if(dist[v]&gt;dist[u]+e[i].weigh)            {                dist[v]=dist[u]+e[i].weigh;                if(!vis[v])                {                    q[++fr]=v;                    c[v]++;                    vis[v]=1;                    if(c[v]&gt;n)                        do something,return;                }            }        }    }}</code></pre><p>还有另一种办法，就是使用DFS跑SPFA，但是会稍微慢一点……吧</p><p>但是优点是负环的判断很简单，只要松弛了未清除标记的点就判定为出现负环。</p><p>下面是<a href="https://www.luogu.org/problemnew/show/P3385" target="_blank" rel="noopener">P3385 【模板】负环</a>的代码（才不是跑P3371的时候T掉了呢，哼！</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000000+110#define inf 0x7fffffffusing namespace std;int n,m,S,cnt;int dist[N],head[N],q[N];bool vis[N],flag;struct edge{    int to,nxt,weigh;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w){    e[++cnt]=(edge){v,head[u],w};    head[u]=cnt;}inline void SPFA(int u){    vis[u]=1;    for(register int i=head[u];i;i=e[i].nxt)    {        int v=e[i].to;        if(dist[v]&gt;dist[u]+e[i].weigh)        {            dist[v]=dist[u]+e[i].weigh;            if(vis[v]||flag)            {                flag=1;                break;            }            SPFA(v);        }    }    vis[u]=0;}int main(){    int T=read();    while(T--)    {        n=read(),m=read();        for(register int i=1;i&lt;=n;i++)            dist[i]=0,vis[i]=0,head[i]=0;        flag=0,cnt=0;        for(register int i=1;i&lt;=m;i++)        {            int u=read(),v=read(),w=read();            add(u,v,w);            if(w&gt;0)                add(v,u,w);        }        for(register int i=1;i&lt;=n;i++)        {            SPFA(i);            if(flag)                break;        }        if(flag)            printf(&quot;YE5\n&quot;);        else            printf(&quot;N0\n&quot;);    }    return 0;}</code></pre><p>再放一道例题：<a href="https://www.luogu.org/problemnew/show/P1027" target="_blank" rel="noopener">P1027 Car的旅行路线</a></p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 400+10#define inf 0x7fffffff#define ri register int#define il inlineusing namespace std;int n,s,t,A,B,cnt,head[N],q[N];double dist[N];bool vis[N];struct Vector{    int x,y;    Vector(int X,int Y)    {        x=X,y=Y;    }    Vector()    {        x=0,y=0;    }    int operator * (const Vector &amp;v)    {        int ret;        ret=x*v.x+y*v.y;        return ret;    }    Vector operator - (const Vector &amp;v)    {        Vector ret;        ret.x=x-v.x;        ret.y=y-v.y;        return ret;    }};struct city{    Vector apt[5];    int T;    void add(int x1,int y1,int x2,int y2,int x3,int y3,int x4,int y4,int t)    {        apt[1].x=x1,apt[1].y=y1,apt[2].x=x2,apt[2].y=y2,apt[3].x=x3,apt[3].y=y3,apt[4].x=x4,apt[4].y=y4;        T=t;    }};struct edge{    int to,nxt;    double weight;};city C[N];edge e[100000];il void work(int x1,int y1,int x2,int y2,int x3,int y3,int &amp;x4,int &amp;y4){    Vector ab(x1-x2,y1-y2),bc(x2-x3,y2-y3),ac(x3-x1,y3-y1);    if(ab*bc==0)    {        x4=x3+x1-x2;        y4=y3+y1-y2;    }    else if(ab*ac==0)    {        x4=x3+x2-x1;        y4=y3+y2-y1;    }    else    {        x4=x1+x2-x3;        y4=y1+y2-y3;    }    return;}il double Vector_module(Vector v){    return sqrt(v.x*v.x+v.y*v.y);}il void add_edge(int u,int v,double w){    e[++cnt]=(edge){v,head[u],w};    head[u]=cnt;}il void SPFA(int S){    int fr=4,tl=0;    for(ri i=1;i&lt;=s;i++)        for(ri j=1;j&lt;=4;j++)            dist[4*(i-1)+j]=inf;    for(ri i=0;i&lt;4;i++)        dist[S+i]=0,vis[S+i]=1,q[i+1]=S+i;    while(tl&lt;fr)    {        int u=q[++tl];        vis[u]=0;        for(ri i=head[u];i;i=e[i].nxt)        {            int v=e[i].to;            if(dist[v]&gt;dist[u]+e[i].weight)            {                dist[v]=dist[u]+e[i].weight;                if(!vis[v])                {                    q[++fr]=v;                    vis[v]=1;                }            }        }    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    while(n--)    {        memset(vis,0,sizeof(vis));        memset(e,0,sizeof(e));        memset(C,0,sizeof(C));        memset(head,0,sizeof(head));        cnt=0;        scanf(&quot;%d %d %d %d&quot;,&amp;s,&amp;t,&amp;A,&amp;B);        for(ri i=1;i&lt;=s;i++)        {            int x1,x2,x3,x4;            int y1,y2,y3,y4;            int T;            scanf(&quot;%d %d %d %d %d %d %d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2,&amp;x3,&amp;y3,&amp;T);            work(x1,y1,x2,y2,x3,y3,x4,y4);            C[i].add(x1,y1,x2,y2,x3,y3,x4,y4,T);        }        for(ri i=1;i&lt;=s;i++)        {            for(ri j=1;j&lt;=3;j++)                for(ri k=j+1;k&lt;=4;k++)                {                    double w=Vector_module(C[i].apt[j]-C[i].apt[k])*C[i].T;                    add_edge(4*(i-1)+j,4*(i-1)+k,w);                    add_edge(4*(i-1)+k,4*(i-1)+j,w);                }            for(ri j=i+1;j&lt;=s;j++)                for(ri k=1;k&lt;=4;k++)                    for(ri l=1;l&lt;=4;l++)                    {                        double w=Vector_module(C[i].apt[k]-C[j].apt[l])*t;                        add_edge(4*(i-1)+k,4*(j-1)+l,w);                        add_edge(4*(j-1)+l,4*(i-1)+k,w);                    }        }        SPFA(4*(A-1)+1);        double ans=inf;        for(ri i=1;i&lt;=4;i++)            ans=min(ans,dist[4*(B-1)+i]);        printf(&quot;%.1lf\n&quot;,ans);    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网络最大流</title>
      <link href="/2018/07/24/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"/>
      <url>/2018/07/24/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>在图中，有这样一类问题：在一张有向图中，指定源点S和汇点T，每条边的最大容量已知，求从S到T的最大流量。</p><p>这就是网络最大流问题，我们可以说的具体一点：一个自来水管道网，你家是汇点，自来水厂是源点，每根管道的粗细是一定的，求能流到你家的水最多有多少。</p><p>这个问题的关键在于，当有找到一条路径的时候，这条路径所经过的边的容量就会被占用一部分。</p><p>我们定义：<br>源点：只有流出去的点<br>汇点：只有流进来的点<br>流量：一条边上流过的流量<br>容量：一条边上可供流过的最大流量<br>残量：一条边上的容量-流量</p><p>模板题：<a href="https://www.luogu.org/problemnew/show/P3376" target="_blank" rel="noopener">P3376 【模板】网络最大流</a></p><p>我在这里介绍以下几种算法：</p><h1 id="1、Edmond-Karp（EK）动能算法"><a href="#1、Edmond-Karp（EK）动能算法" class="headerlink" title="1、Edmond-Karp（EK）动能算法"></a>1、Edmond-Karp（EK）<del>动能</del>算法</h1><p>EK这东西比较的简单粗暴，但复杂度是平方级别的O($m^2n$)，所以跑的比较慢</p><p>首先我们说如果所有边上的流量都没有超过容量(不大于容量)，那么就把这一组流量，或者说，这个流，称为一个可行流。一个最简单的例子就是，零流，即所有的流量都是0的流。</p><p>我们就从这个零流开始考虑，假如有这么一条路，这条路从源点开始一直一段一段的连到了汇点，并且，这条路上的每一段都满足流量&lt;容量，注意，是严格的&lt;,而不是&lt;=。那么，我们一定能找到这条路上的每一段的(容量-流量)的值当中的最小值delta。我们把这条路上每一段的流量都加上这个delta，一定可以保证这个流依然是可行流，这是显然的。</p><p>这样我们就得到了一个更大的流，他的流量是之前的流量+delta，而这条路就叫做增广路。</p><p>我们不断地从起点开始寻找增广路，每次都对其进行增广，直到源点和汇点不连通，也就是找不到增广路为止。当找不到增广路的时候，当前的流量就是最大流，这个结论非常重要。</p><p>那么我们寻找增广路的时候就简单的从源点开始做bfs，不断的修改这条路上的delta值，直到找到源点或找不到增广路。</p><p>但是这样会出一点锅，为什么呢？</p><p>来看下面这张图：</p><p><img src="http://b287.photo.store.qq.com/psb?/V137oTmC2F4y9l/YJJRoy4hpnb557YkUnYBKl4r05m2jumDGIUd4Ndd408!/c/dB8BAAAAAAAA&amp;bo=fQJVAX0CVQEBACc!" alt=""></p><p>这个图我们一看就知道正确的方法是S-1-T和S-2-T，最大流就是2。但如果你的程序走过了S-1-2-T这条路，图就变成了这样：</p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/22Vml49RkiVKleE9Uqrk0UcbY467yZdQs*NPzCgQENI!/c/dCEBAAAAAAAA&amp;bo=bwJAAW8CQAEBACc!" alt=""></p><p>这样源点与汇点就不连通了，但此时毫无疑问并不是最大值。那么该怎么办呢？我们可以考虑加入反向边，反向边初始容量都为0，然后在一条边的容量减少delta的时候把反向边的容量加上delta。</p><p>就拿上面那个图来说，加入反向边以后图就变成了这样：</p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/0lQWOEvDGApYSPwhlJIYzeGXxMTJ0IeDphZF3dKEUKQ!/c/dCEBAAAAAAAA&amp;bo=bwJAAW8CQAEBACc!" alt=""></p><p>然后就可以搜到这样一条路（亮瞎眼的那条黄色路径）：</p><p><img src="http://b290.photo.store.qq.com/psb?/V137oTmC2F4y9l/xxlMnLH1kAT6N6YCuZ2Bt7A7VkEtR1KxGtAa8CLxWyE!/c/dCIBAAAAAAAA&amp;bo=dgJHAXYCRwEBACc!" alt=""></p><p>这样就可以得到2的正确答案了。</p><p>那么这样为什么是对的呢？很简单，走2-1的时候就相当于把1-2这条边已经走的退了回去，这样就又变成了S-1-T和S-2-T两条路了。这样就给了程序一个反悔的机会。</p><p>然后就完了DA☆ZE！</p><p>贴代码（236ms）：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110using namespace std;int n,m,S,T,cnt,ans;int head[N],q[N],pre[N];bool vis[N];struct edge{    int fr,to,nxt,weigh;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline int add(int u,int v,int w){    e[cnt]=(edge){u,v,head[u],w};    head[u]=cnt++;}inline bool bfs(int s,int t){    memset(vis,0,sizeof(vis));    memset(pre,-1,sizeof(pre));    int fr=1,tl=0;    q[1]=s,vis[s]=1;    while(tl&lt;fr)    {        int u=q[++tl];        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(!vis[v]&amp;&amp;e[i].weigh&gt;0)            {                pre[v]=i;                vis[v]=1;                if(v==t)                    return true;                q[++fr]=v;            }        }    }    return false;}inline int EK(int s,int t){    int mn;    while(bfs(s,t))    {        mn=0x7fffffff;        int i=pre[t];        while(i!=-1)        {            mn=min(mn,e[i].weigh);            i=pre[e[i].fr];        }        i=pre[t];        while(i!=-1)        {            e[i].weigh-=mn;            e[i^1].weigh+=mn;            i=pre[e[i].fr];        }        ans+=mn;    }    return ans;}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u,v,w;        u=read(),v=read(),w=read();        add(u,v,w);        add(v,u,0);    }    printf(&quot;%d&quot;,EK(S,T));    return 0;}</code></pre><p>pre数组的作用是记录到达每个顶点的边。</p><p>【注明】本段讲解部分引用<a href="http://blog.sina.com.cn/s/blog_6cf509db0100uy5n.html" target="_blank" rel="noopener">最大流模板【EdmondsKarp算法，简称EK算法，O(m^2n)】</a></p><hr><h1 id="2、Dinic算法"><a href="#2、Dinic算法" class="headerlink" title="2、Dinic算法"></a>2、Dinic算法</h1><p>这个算法的复杂度为O($n^2m$)，虽然仍旧是平方级别，但由于点的数量一般比边的数量少，所以整体比EK跑的要快。</p><h2 id="普通Dinic"><a href="#普通Dinic" class="headerlink" title="普通Dinic"></a>普通Dinic</h2><p>由于EK算法本身的特性，如果之前那张图变成了这样：</p><p><img src="http://b290.photo.store.qq.com/psb?/V137oTmC2F4y9l/Rfjr6Tzt0OzwZFzCs0wflcrUPnPOxau0OER3yfSfJy0!/c/dCIBAAAAAAAA&amp;bo=ZwI3AWcCNwEBACc!" alt=""></p><p>情况就很不乐观了。因为一次增广后图变成这样：</p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/0bVmWeAQCGTDClIveLRvxMjAJ7J0Bo2o0RKu5qJb76I!/c/dCEBAAAAAAAA&amp;bo=ZwI2AWcCNgEBACc!" alt=""></p><p>然后再BFS一次：</p><p><img src="http://b168.photo.store.qq.com/psb?/V137oTmC2F4y9l/TZP8DHtCsbjjLagiCIpfM6cwsYaN3G7u.W9jpUUf0X8!/c/dKgAAAAAAAAA&amp;bo=ZwI1AWcCNQEBACc!" alt=""></p><p>就这么做下去的话毫无疑问会爆炸的。</p><p>所以我们在这里引入一个分层图的概念。对于每一个点，我们根据从源点开始的BFS序列确定其深度，然后进行若干次DFS寻找增广路，每次由u推出的点v的深度必须是u的深度+1，这样就可以达到分层的效果。</p><p>比如说还是上面那张图，它分层后就是这样：</p><p><img src="http://b290.photo.store.qq.com/psb?/V137oTmC2F4y9l/zaoXBtZ4bdd6fsgAsl7iH8PugxGt7AIIBaW2H0Yc6DY!/c/dCIBAAAAAAAA&amp;bo=bgI0AW4CNAEBACc!" alt=""></p><p>然后很明显1和2这两个点在同一深度，它们在DFS中是无法互相搜到的。</p><p>至于BFS过程本身的变化其实不是特别大，对于一个点v进队的条件，不过是从EK的“当前边的残量大于0”变成了“当前边的残量大于0且v点未分配深度”而已，如果v没有分配深度，就把它的深度赋为u的深度+1。</p><p>然后在Dinic的主过程中就只需要不停的寻找增广路知道再也找不到为止。</p><p>以下是代码（手写520ms）：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110#define inf 0x7fffffffusing namespace std;int n,m,S,T,cnt;int deep[N/10],head[N],q[N/10];struct edge{    int to,nxt,weigh;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w){    e[cnt]=(edge){v,head[u],w};    head[u]=cnt++;}inline bool bfs(int s,int t){    int fr=1,tl=0;    memset(deep,0,sizeof(deep));    deep[s]=1;    q[1]=s;    while(tl&lt;fr)    {        int u=q[++tl];        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(deep[v]==0&amp;&amp;e[i].weigh&gt;0)            {                deep[v]=deep[u]+1;                q[++fr]=v;            }        }    }    if(!deep[t])        return 0;    return 1;}inline int dfs(int u,int t,int dist){    if(u==t)        return dist;    for(register int i=head[u];i!=-1;i=e[i].nxt)    {        int v=e[i].to;        if(deep[v]==deep[u]+1&amp;&amp;e[i].weigh&gt;0)        {            int dis=dfs(v,t,min(dist,e[i].weigh));            if(dis&gt;0)            {                e[i].weigh-=dis;                e[i^1].weigh+=dis;                return dis;            }        }    }    return 0;}inline int Dinic(int s,int t){    int Ans=0;    while(bfs(s,t))    {        while(int delta=dfs(s,t,inf))            Ans+=delta;    }    return Ans;}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read();        add(u,v,w);        add(v,u,0);    }    printf(&quot;%d&quot;,Dinic(S,T));    return 0;}</code></pre><h2 id="当前弧优化的Dinic"><a href="#当前弧优化的Dinic" class="headerlink" title="当前弧优化的Dinic"></a>当前弧优化的Dinic</h2><p>如果你比较细心的话大概就会注意到，EK的时间是236ms，而Dinic却要520ms。可这不对啊，说好的EK复杂度更高呢？原因就在于<del>数据太水</del>每次搜的时候都是从第一条边开始的，然后就导致有许多边被重复搜索，就跑得很慢啦。</p><p>那么我们就记录u之前循环到了哪条边然后直接从这条边开始不就完了吗？</p><p>对，就是这样，只要多开一个cur数组记录一下就行了，然后在DFS的循环中i改变的时候也同时改变cur来记录当前弧，但是不要忘记每一次建立完分层图后都要把cur置为每一个点的第一条边。</p><p>然后就可以跑的很快了DA☆ZE！</p><p>贴代码（手写132ms）：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110#define inf 0x7fffffffusing namespace std;int n,m,S,T,cnt;int deep[N/10],head[N],q[N/10],cur[N];struct edge{    int to,nxt,weigh;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)    {        if(ch==&#39;-&#39;)            f=-1;        ch=getchar();    }    while(ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline void add(int u,int v,int w){    e[cnt]=(edge){v,head[u],w};    head[u]=cnt++;}inline bool bfs(int s,int t){    int fr=1,tl=0;    memset(deep,0,sizeof(deep));    deep[s]=1;    q[1]=s;    while(tl&lt;fr)    {        int u=q[++tl];        for(register int i=head[u];i!=-1;i=e[i].nxt)        {            int v=e[i].to;            if(deep[v]==0&amp;&amp;e[i].weigh&gt;0)            {                deep[v]=deep[u]+1;                q[++fr]=v;            }        }    }    if(!deep[t])        return 0;    return 1;}inline int dfs(int u,int t,int dist){    if(u==t)        return dist;    for(register int&amp; i=cur[u];i!=-1;i=e[i].nxt)//当然也可以去掉‘&amp;’然后在循环最后加一句“cur[u]=e[i].nxt”    {        int v=e[i].to;        if(deep[v]==deep[u]+1&amp;&amp;e[i].weigh&gt;0)        {            int dis=dfs(v,t,min(dist,e[i].weigh));            if(dis&gt;0)            {                e[i].weigh-=dis;                e[i^1].weigh+=dis;                return dis;            }        }    }    return 0;}inline int Dinic(int s,int t){    int Ans=0;    while(bfs(s,t))    {        for(register int i=1;i&lt;=n;i++)            cur[i]=head[i];        while(int delta=dfs(s,t,inf))            Ans+=delta;    }    return Ans;}int main(){    memset(head,-1,sizeof(head));    n=read(),m=read(),S=read(),T=read();    for(register int i=1;i&lt;=m;i++)    {        int u=read(),v=read(),w=read();        add(u,v,w);        add(v,u,0);    }    printf(&quot;%d&quot;,Dinic(S,T));    return 0;}</code></pre><p>然后我们就得到了真正的Dinic算法</p><p>【注明】本段讲解部分引用<a href="http://sycstudio.com/" target="_blank" rel="noopener">SYCstudio</a>大佬的<a href="https://www.cnblogs.com/SYCstudio/p/7260613.html" target="_blank" rel="noopener">Dinic算法（研究总结，网络流）</a></p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络流 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>莫队</title>
      <link href="/2018/07/24/%E8%8E%AB%E9%98%9F/"/>
      <url>/2018/07/24/%E8%8E%AB%E9%98%9F/</url>
      <content type="html"><![CDATA[<p>首先%一波莫涛队长orz</p><h1 id="普通莫队"><a href="#普通莫队" class="headerlink" title="普通莫队"></a>普通莫队</h1><p>由于没有什么板子，这里放一道基础题。</p><p>给定一个序列，其中有n个元素，有m次查询，每次查询要求输出区间[l,r]内出现次数不少于k的数字的个数。</p><p>其实乍一看，好像就是可以用暴力做……但其实莫队本身也和暴力区别不大，基础思路就是将序列分成sqrt(n)个块，然后在每个块中进行操作。</p><p>以下是代码</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 100000+100using namespace std;struct node{    int l,r,k,id,t;}ask[N];int n,m,blo,a[N],num[N],ans[N],cnt[N];inline bool cmp(node x,node y){    if(x.t==y.t)        return x.r&lt;y.r;    return x.t&lt;y.t;}inline void add(int x){    num[a[x]]++;    cnt[num[a[x]]]++;}inline void Minus(int x){    num[a[x]]--;    cnt[num[a[x]]]--;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    blo=sqrt(n);    for(register int i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;a[i]);    for(register int i=1;i&lt;=m;i++)    {        scanf(&quot;%d%d%d&quot;,&amp;ask[i].l,&amp;ask[i].r,&amp;ask[i].k);        ask[i].id=i;        ask[i].t=ask[i].l/blo;    }    sort(ask+1,ask+1+m,cmp);    for(register int i=ask[1].l;i&lt;=ask[1].r;i++)    {        num[a[i]]++;        cnt[num[a[i]]]++;    }    ans[ask[1].id]=cnt[ask[1].k];    int L=ask[1].l;    int R=ask[1].r;    for(register int i=2;i&lt;=m;i++)    {        while(L&gt;ask[i].l)        {            L--;            add(L);        }        while(R&lt;ask[i].r)        {            R++;            add(R);        }        while(L&lt;ask[i].l)        {            Minus(L);            L++;        }        while(R&gt;ask[i].r)        {            Minus(R);            R--;        }        ans[ask[i].id]=cnt[ask[i].k];    }    for(register int i=1;i&lt;=m;i++)        printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><p>在这个程序中，我们用num[j]来记录j的出现次数，用cnt[j]记录出现次数不小于j的数的个数，在离线操作的基础上，对每次查询依照左端点所在的块进行排序，如果所在块相同则按照右端点进行排序，可以保证L，R两个指针的跳动次数尽可能的小以降低复杂度。</p><p>然后在对每次查询的更新中不断跳动L、R，拓宽区间的时候先拓宽再操作，缩小区间的时候则先操作再缩小，最终在记录下来的ans数组中查询答案。</p><p>以下是几道题：</p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3809" target="_blank" rel="noopener">BZOJ 3809: Gty的二逼妹子序列</a></p><p>手写AC（调了一下午的绝望）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000000+1000using namespace std;int n,m,blo,cnt;int a[100005],ans[1000005];int bel[100005];int num[100005],bloans[1005];struct node{    int l,r,p,q,id;}ask[1000005];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])        return x.r&lt;y.r;    return bel[x.l]&lt;bel[y.l];}inline void add(int x){    num[a[x]]++;    if(num[a[x]]==1)        bloans[bel[a[x]]]++;}inline void Minus(int x){    num[a[x]]--;    if(!num[a[x]])        bloans[bel[a[x]]]--;}inline int query(int x,int y){    int ret=0;    int L=bel[x];    int R=bel[y];    if(L==R)    {        for(register int i=x;i&lt;=y;i++)        {            if(num[i])                ret++;        }    }    else    {        for(register int i=x;i&lt;(L+1)*blo;i++)        {            if(num[i])                ret++;        }        for(register int i=R*blo;i&lt;=y;i++)        {            if(num[i])                ret++;        }        for(register int i=L+1;i&lt;R;i++)            ret+=bloans[i];    }    return ret;}int main(){    n=read();    m=read();    blo=sqrt(n);    for(register int i=1;i&lt;=n;i++)    {        a[i]=read();        bel[i]=i/blo;    }    for(register int i=1;i&lt;=m;i++)    {        ask[i].l=read();        ask[i].r=read();        ask[i].p=read();        ask[i].q=read();        ask[i].id=i;    }    sort(ask+1,ask+1+m,cmp);    int L=1;    int R=0;    for(register int i=1;i&lt;=m;i++)    {        while(L&gt;ask[i].l)        {            L--;            add(L);        }        while(R&lt;ask[i].r)        {            R++;            add(R);        }        while(L&lt;ask[i].l)        {            Minus(L);            L++;        }        while(R&gt;ask[i].r)        {            Minus(R);            R--;        }        ans[ask[i].id]=query(ask[i].p,ask[i].q);    }    for(register int i=1;i&lt;=m;i++)        printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><p>这道题说起来难度其实不大，一个值域分块的莫队保证m√n的复杂度完全没压力，就是这个28Mb的空间稍微有点坑。</p><p><a href="https://www.luogu.org/problemnew/show/P4137" target="_blank" rel="noopener"> P4137 Rmq Problem / mex</a></p><p>手写AC（一遍A O2-1296ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+1000using namespace std;struct node{    int l,r,id;}ask[N];int n,m,blo,now,a[N],num[N],ans[N],bel[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])        return x.r&lt;y.r;    return bel[x.l]&lt;bel[y.l];}inline void add(int x){    if(a[x]&gt;n)        return;    num[a[x]]++;    if(a[x]==now)    {        while(num[now])            now++;    }}inline void Minus(int x){    if(a[x]&gt;n)        return;    num[a[x]]--;    if(a[x]&lt;now)        if(!num[a[x]])            now=a[x];}int main(){    n=read();    m=read();    blo=sqrt(n);    for(register int i=1;i&lt;=n;i++)    {        a[i]=read();        bel[i]=i/blo;    }    for(register int i=1;i&lt;=m;i++)    {        ask[i].l=read();        ask[i].r=read();        ask[i].id=i;    }    sort(ask+1,ask+1+m,cmp);    int L=1;    int R=0;    for(register int i=1;i&lt;=m;i++)    {        while(L&gt;ask[i].l)        {            L--;            add(L);        }        while(R&lt;ask[i].r)        {            R++;            add(R);        }        while(L&lt;ask[i].l)        {            Minus(L);            L++;        }        while(R&gt;ask[i].r)        {            Minus(R);            R--;        }        ans[ask[i].id]=now;    }    for(register int i=1;i&lt;=m;i++)        printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><p>仍旧是对0到n进行分块，因为最坏情况是a[1]~a[n]对应0~n-1。所以就在上一题的基础上修改一下更新操作，在每次更新的时候与当前的最小值进行比较，如果最小值数量增加就寻找新的最优解，如果有新的解出现并且优于最优解就更新最优解。</p><p><a href="http://www.lydsy.com/JudgeOnline/problem.php?id=3236" target="_blank" rel="noopener">BZOJ 3236: [AHOI2013]作业</a></p><p>手写AC</p><pre><code>#include &lt;bits/stdc++.h&gt;#define N 1000000+1000using namespace std;int n,m,blo,cnt;int a[100005],ans[1000005][2];int bel[100005];int num[100005],bloans[1005],bloans1[1005];struct node{    int l,r,p,q,id;}ask[1000005];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])        return x.r&lt;y.r;    return bel[x.l]&lt;bel[y.l];}inline void add(int x){    num[a[x]]++;    bloans1[bel[a[x]]]++;    if(num[a[x]]==1)        bloans[bel[a[x]]]++;}inline void Minus(int x){    num[a[x]]--;    bloans1[bel[a[x]]]--;    if(!num[a[x]])        bloans[bel[a[x]]]--;}inline int query(int x,int y){    int ret=0;    int L=bel[x];    int R=bel[y];    if(L==R)    {        for(register int i=x;i&lt;=y;i++)        {            if(num[i])                ret++;        }    }    else    {        for(register int i=x;i&lt;(L+1)*blo;i++)        {            if(num[i])                ret++;        }        for(register int i=R*blo;i&lt;=y;i++)        {            if(num[i])                ret++;        }        for(register int i=L+1;i&lt;R;i++)            ret+=bloans[i];    }    return ret;}inline int Query(int x,int y){    int ret=0;    int L=bel[x];    int R=bel[y];    if(L==R)    {        for(register int i=x;i&lt;=y;i++)            ret+=num[i];    }    else    {        for(register int i=x;i&lt;(L+1)*blo;i++)            ret+=num[i];        for(register int i=R*blo;i&lt;=y;i++)            ret+=num[i];        for(register int i=L+1;i&lt;R;i++)            ret+=bloans1[i];    }    return ret;}int main(){    n=read();    m=read();    blo=sqrt(n);    for(register int i=1;i&lt;=n;i++)    {        a[i]=read();        bel[i]=i/blo;    }    for(register int i=1;i&lt;=m;i++)    {        ask[i].l=read();        ask[i].r=read();        ask[i].p=read();        ask[i].q=read();        ask[i].id=i;    }    sort(ask+1,ask+1+m,cmp);    int L=1;    int R=0;    for(register int i=1;i&lt;=m;i++)    {        while(L&gt;ask[i].l)        {            L--;            add(L);        }        while(R&lt;ask[i].r)        {            R++;            add(R);        }        while(L&lt;ask[i].l)        {            Minus(L);            L++;        }        while(R&gt;ask[i].r)        {            Minus(R);            R--;        }        ans[ask[i].id][0]=query(ask[i].p,ask[i].q);        ans[ask[i].id][1]=Query(ask[i].p,ask[i].q);    }    for(register int i=1;i&lt;=m;i++)        printf(&quot;%d %d\n&quot;,ans[i][1],ans[i][0]);    return 0;}</code></pre><p>几乎无思维难度，在BZOJ 3809的基础上加一个查询数量的函数就行了</p><h1 id="带修莫队"><a href="#带修莫队" class="headerlink" title="带修莫队"></a>带修莫队</h1><p><a href="https://www.luogu.org/recordnew/show/6262891" target="_blank" rel="noopener">P1903 [国家集训队]数颜色</a></p><p>手写AC</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 100000+100using namespace std;int n,m,blo,cnt,t,Time;int a[N],ans[N],bel[N],num[N],bloans[N],now[N];struct node{    int l,r,tim,id;}ask[N];struct change{    int pos,New,Old;}chg[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])    {        if(bel[x.r]==bel[y.r])            return x.tim&lt;y.tim;        return bel[x.r]&lt;bel[y.r];    }    return bel[x.l]&lt;bel[y.l];}inline void add(int x){    num[x]++;    if(num[x]==1)        cnt++;}inline void Minus(int x){    num[x]--;    if(!num[x])        cnt--;}inline void Change(int l,int r,int x,int d){    if(l&lt;=x&amp;&amp;x&lt;=r)    {        add(d);        Minus(a[x]);    }    a[x]=d;}int main(){    n=read();    m=read();    blo=pow(n,2.0/3);    for(register int i=1;i&lt;=n;i++)    {        a[i]=read();        now[i]=a[i];        bel[i]=i/blo;    }    for(register int i=1;i&lt;=m;i++)    {        char ch;        cin&gt;&gt;ch;        if(ch==&#39;Q&#39;)        {            ask[++t].l=read();            ask[t].r=read();            ask[t].tim=Time;            ask[t].id=t;        }        else        {            chg[++Time].pos=read();            chg[Time].New=read();            chg[Time].Old=now[chg[Time].pos];            now[chg[Time].pos]=chg[Time].New;        }    }    sort(ask+1,ask+1+t,cmp);    int L=1;    int R=0;    int T=0;    for(register int i=1;i&lt;=t;i++)    {        while(T&lt;ask[i].tim)        {            T++;            Change(L,R,chg[T].pos,chg[T].New);        }        while(T&gt;ask[i].tim)        {            Change(L,R,chg[T].pos,chg[T].Old);            T--;        }        while(L&gt;ask[i].l)        {            L--;            add(a[L]);        }        while(R&lt;ask[i].r)        {            R++;            add(a[R]);        }        while(L&lt;ask[i].l)        {            Minus(a[L]);            L++;        }        while(R&gt;ask[i].r)        {            Minus(a[R]);            R--;        }        ans[ask[i].id]=cnt;    }    for(register int i=1;i&lt;=t;i++)        printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><p>就难度系数而言其实并不算高，作为带修莫队的板子题来说挺不错的。</p><p>那么以下是带修莫队的思路。</p><p>如果我们把每次修改当作一次时间的推移，然后就只需要在查询中加入一个新的关键字Tim，也就是时间，仅在两个询问的l和r都在同一分块中的情况才依照Tim进行排序。</p><p>然后在操作中进行L和R的跳动之前先进行时间指针T的跳动，使时间到达当前查询的时间点。由于时间需要不停的跳动，所以对于每次修改操作要另开一个结构体记录修改位置（pos）、修改后的值（New）和修改前的值（Old），这个Old在后面时间倒流的时候会有用。</p><p>对于每次T的跳动进行一次Change操作，时间增加就将指定位置的值修改为T++后的修改操作的New值，时间倒流就先将指定位置的值修改为T时修改操作的Old值（即还原），然后就没什么区别了。</p><p>对于Change操作也比较简单，如果当前位置在[L,R]区间中就将修改后的值Add进去，然后将原位置上的值Minus掉，如果不在区间内就直接将原位置数据赋为修改后的值，因为以后指针跳动的时候会自行更新的。</p><p>稍微扯两句，带修莫队的复杂度经过某些dalao的证明后确定为n^(5/3),此时分为n^(1/3)块，每块有n^(2/3)个元素，所以blo=pow(n,2.0/3)。</p><h1 id="树上莫队"><a href="#树上莫队" class="headerlink" title="树上莫队"></a>树上莫队</h1><p>例题：<a href="http://www.lydsy.com/JudgeOnline/problem.php?id=4129" target="_blank" rel="noopener">BZOJ 4129: Haruna’s Breakfast</a><del>（小天使！！！！！！！！）</del></p><p>什么，树上能跑莫队，还带修改？那岂不是要爆裂吗？</p><p>这是我第一次听说树上莫队时的想法。</p><p>不过我们知道对于一棵树，还有DFS序这种美妙的东西，这样的话树不就变成序列了吗？</p><p>比如说对于下面一棵树：</p><p><img src="http://b117.photo.store.qq.com/psb?/V137oTmC2F4y9l/rCZWGAv7jto.1koazTeSrgBU4uyU.JxZDsnZZbZdt74!/c/dHUAAAAAAAAA&amp;bo=mwEtAZsBLQEBACc!" alt=""></p><p>它的DFS序就是：1 2 4 4 5 5 2 3 6 6 7 7 3 1</p><p>然后求j,k两点之间的链上的mex值。我们用in[i]记录i第一次出现的位置，用out[i]记录i最后出现的位置。</p><p>首先假设j是k的祖先，那么我们可以发现[j,k]间的信息就存在in[j],in[k]之间或out[j],out[k]之间，对于出现两次的数我们就忽略掉好了。</p><p>那么如果j不是k的祖先呢？我们会发现[j,k]之间的信息存在了in[j],out[k]之间或者out[j],in[k]之间，同样我们忽略出现了两次的数。但是如果仔细看一下就会发现，j、k的LCA好像不见了，那么我们只要特殊处理一下LCA就OK了。</p><p>然后就可以用序列上的莫队来处理了DA☆ZE！（不过代码比较长就是了）</p><p>以下是AC代码（我可是自带大常数和大空间的男人）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500000+100using namespace std;int n,m,blo,cnt,Time,tot,cur;int a[N],in[N],dfn[N],ans[N],bel[N],num[N],out[N],now[N];int siz[N],deep[N],fa[N],son[N],p[N],top[N];short tag[N];struct node{    int l,r,tim,id,Lca;}ask[N];struct change{    int pos,New,Old;}chg[N];struct edge{    int to,nxt;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])    {        if(bel[x.r]==bel[y.r])            return x.tim&lt;y.tim;        return bel[x.r]&lt;bel[y.r];    }    return bel[x.l]&lt;bel[y.l];}inline void add_edge(int u,int v){    e[++tot]=(edge){v,p[u]};    p[u]=tot;}inline void dfs(int x){    siz[x]++;    dfn[++dfn[0]]=x;    in[x]=dfn[0];    int f=-1;    for(int i=p[x];i;i=e[i].nxt)    {        int v=e[i].to;        if(v==fa[x])            continue;        deep[v]=deep[x]+1;        fa[v]=x;        dfs(v);        siz[x]+=siz[v];        if(siz[v]&gt;f)        {            son[x]=v;            f=siz[v];        }    }    if(f==-1)        son[x]=x;    dfn[++dfn[0]]=x;    out[x]=dfn[0];}inline int LCA(int x,int y){    while(top[x]!=top[y])    {        if(deep[top[x]]&lt;deep[top[y]])            swap(x,y);        x=fa[top[x]];    }    if(deep[x]&gt;deep[y])        swap(x,y);    return x;}inline void choose(int x,int y,int cur){    int l=0,r=0,lca=LCA(x,y);    if(x==lca||y==lca)    {        if(abs(in[x]-in[y])&lt;abs(out[x]-out[y]))            l=min(in[x],in[y]),r=max(in[x],in[y]);        else            l=min(out[x],out[y]),r=max(out[x],out[y]);        lca=0;    }    else    {        if(abs(in[x]-out[y])&lt;abs(out[x]-in[y]))            l=min(in[x],out[y]),r=max(in[x],out[y]);        else            l=min(out[x],in[y]),r=max(out[x],in[y]);    }    ask[cur]=(node){l,r,Time,cur,lca};}inline void add(int x){    if(x&gt;n)        return;    num[x]++;    if(x==cnt)    {        while(num[cnt])            cnt++;    }}inline void Minus(int x){    if(x&gt;n)        return;    num[x]--;    if(x&lt;cnt)        if(!num[x])            cnt=x;}inline void Work(int x){    if(tag[x])        Minus(a[x]);    else        add(a[x]);    tag[x]^=1;}inline void Change(int pos,int x){    if(tag[pos])    {        Work(pos);        a[pos]=x;        Work(pos);    }    else        a[pos]=x;}int main(){    n=read(),m=read();    blo=pow(n&lt;&lt;1,2.0/3)*0.7;    for(register int i=1;i&lt;=n;i++)        now[i]=a[i]=read();    for(register int i=1;i&lt;n;i++)    {        int x,y;        x=read(),y=read();        add_edge(x,y),add_edge(y,x);    }    dfs(1);    for(register int i=1;i&lt;=dfn[0];i++)    {        bel[i]=i/blo;        if(top[dfn[i]])            continue;        else if(dfn[i]==son[fa[dfn[i]]])            top[dfn[i]]=top[fa[dfn[i]]];        else            top[dfn[i]]=dfn[i];    }    for(register int i=1;i&lt;=m;i++)    {        int c=read();        if(c)        {            int x=read(),y=read();            choose(x,y,++cur);        }        else        {            int x=read(),y=read();            chg[++Time]=(change){x,y,now[x]};            now[x]=y;        }    }    sort(ask+1,ask+1+cur,cmp);    int L=1,R=0,T=0;    for(register int i=1;i&lt;=cur;i++)    {        while(T&lt;ask[i].tim)        {            T++;            Change(chg[T].pos,chg[T].New);        }        while(T&gt;ask[i].tim)        {            Change(chg[T].pos,chg[T].Old);            T--;        }        while(L&gt;ask[i].l)        {            L--;            Work(dfn[L]);        }        while(R&lt;ask[i].r)        {            R++;            Work(dfn[R]);        }        while(L&lt;ask[i].l)        {            Work(dfn[L]);            L++;        }        while(R&gt;ask[i].r)        {            Work(dfn[R]);            R--;        }        if(ask[i].Lca)            Work(ask[i].Lca);        ans[ask[i].id]=cnt;        if(ask[i].Lca)            Work(ask[i].Lca);    }    for(register int i=1;i&lt;=cur;i++)        printf(&quot;%d\n&quot;,ans[i]);    return 0;}</code></pre><p>这里LCA我用的树剖（当然倍增也可以啦</p><p>顺便注明一下，那个tag数组是用来记录某个位置在区间里出现了几次，因为不论是0次还是2次都是不计入答案的，所以只要把2次当0次看就可以避免很多复杂的讨论了。然后修改的时候tag是0就加，tag是1就减，最后要把tag进行变换（即0-&gt;1，1-&gt;0）。</p><p>要说修改与mex这两个的话，还是看上面的讲解吧。</p><p>再说起来，其实树上莫队可以在树上分块的基础上搞，但是我太蒻了，看不懂dalao的讲解。</p><p>还有一题：<a href="https://www.luogu.org/problemnew/show/P4074#sub" target="_blank" rel="noopener">P4074 [WC2013]糖果公园</a></p><p>几乎就是板子吧，具体自己看代码（其实没啥差别）</p><p>手写AC（O2-6s，莫名其妙就Rank 5了）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500000+100using namespace std;int n,m,blo,Time,tot,cur,q;int a[N],in[N],dfn[N],bel[N],num[N],out[N],now[N];int siz[N],deep[N],fa[N],son[N],p[N],top[N];short tag[N];long long Ans,ans[N],W[N],V[N];struct node{    int l,r,tim,id,Lca;}ask[N];struct change{    int pos,New,Old;}chg[N];struct edge{    int to,nxt;}e[N];inline int read(){    int x=0,f=1;    char ch=getchar();    while(ch&gt;&#39;9&#39;||ch&lt;&#39;0&#39;)    {        if(f==&#39;-&#39;)            f=-1;        ch=getchar();    }    while (ch&gt;=&#39;0&#39;&amp;&amp;ch&lt;=&#39;9&#39;)    {        x=x*10+ch-&#39;0&#39;;        ch=getchar();    }    return x*f;}inline bool cmp(node x,node y){    if(bel[x.l]==bel[y.l])    {        if(bel[x.r]==bel[y.r])            return x.tim&lt;y.tim;        return bel[x.r]&lt;bel[y.r];    }    return bel[x.l]&lt;bel[y.l];}inline void add_edge(int u,int v){    e[++tot]=(edge){v,p[u]};    p[u]=tot;}inline void dfs(int x){    siz[x]++;    dfn[++dfn[0]]=x;    in[x]=dfn[0];    int f=-1;    for(int i=p[x];i;i=e[i].nxt)    {        int v=e[i].to;        if(v==fa[x])            continue;        deep[v]=deep[x]+1;        fa[v]=x;        dfs(v);        siz[x]+=siz[v];        if(siz[v]&gt;f)        {            son[x]=v;            f=siz[v];        }    }    if(f==-1)        son[x]=x;    dfn[++dfn[0]]=x;    out[x]=dfn[0];}inline int LCA(int x,int y){    while(top[x]!=top[y])    {        if(deep[top[x]]&lt;deep[top[y]])            swap(x,y);        x=fa[top[x]];    }    if(deep[x]&gt;deep[y])        swap(x,y);    return x;}inline void choose(int x,int y,int cur){    int l=0,r=0,lca=LCA(x,y);    if(x==lca||y==lca)    {        if(abs(in[x]-in[y])&lt;abs(out[x]-out[y]))            l=min(in[x],in[y]),r=max(in[x],in[y]);        else            l=min(out[x],out[y]),r=max(out[x],out[y]);        lca=0;    }    else    {        if(abs(in[x]-out[y])&lt;abs(out[x]-in[y]))            l=min(in[x],out[y]),r=max(in[x],out[y]);        else            l=min(out[x],in[y]),r=max(out[x],in[y]);    }    ask[cur]=(node){l,r,Time,cur,lca};}inline void add(int x){    num[x]++;    Ans+=W[num[x]]*V[x];}inline void Minus(int x){    Ans-=W[num[x]]*V[x];    num[x]--;}inline void Work(int x){    if(tag[x])        Minus(a[x]);    else        add(a[x]);    tag[x]^=1;}inline void Change(int pos,int x){    if(tag[pos])    {        Work(pos);        a[pos]=x;        Work(pos);    }    else        a[pos]=x;}int main(){    n=read(),m=read(),q=read();    blo=pow(n&lt;&lt;1,2.0/3)*0.7;    for(register int i=1;i&lt;=m;i++)        V[i]=read();    for(register int i=1;i&lt;=n;i++)        W[i]=read();    for(register int i=1;i&lt;n;i++)    {        int x,y;        x=read(),y=read();        add_edge(x,y),add_edge(y,x);    }    dfs(1);    for(register int i=1;i&lt;=n;i++)        now[i]=a[i]=read();    for(register int i=1;i&lt;=dfn[0];i++)    {        bel[i]=i/blo;        if(top[dfn[i]])            continue;        else if(dfn[i]==son[fa[dfn[i]]])            top[dfn[i]]=top[fa[dfn[i]]];        else            top[dfn[i]]=dfn[i];    }    for(register int i=1;i&lt;=q;i++)    {        int c=read();        if(c)        {            int x=read(),y=read();            choose(x,y,++cur);        }        else        {            int x=read(),y=read();            chg[++Time]=(change){x,y,now[x]};            now[x]=y;        }    }    sort(ask+1,ask+1+cur,cmp);    int L=1,R=0,T=0;    for(register int i=1;i&lt;=cur;i++)    {        while(T&lt;ask[i].tim)        {            T++;            Change(chg[T].pos,chg[T].New);        }        while(T&gt;ask[i].tim)        {            Change(chg[T].pos,chg[T].Old);            T--;        }        while(L&gt;ask[i].l)        {            L--;            Work(dfn[L]);        }        while(R&lt;ask[i].r)        {            R++;            Work(dfn[R]);        }        while(L&lt;ask[i].l)        {            Work(dfn[L]);            L++;        }        while(R&gt;ask[i].r)        {            Work(dfn[R]);            R--;        }        if(ask[i].Lca)            Work(ask[i].Lca);        ans[ask[i].id]=Ans;        if(ask[i].Lca)            Work(ask[i].Lca);    }    for(register int i=1;i&lt;=cur;i++)        printf(&quot;%lld\n&quot;,ans[i]);    return 0;}</code></pre><p>以上就是莫队——一个优雅的暴力算法</p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
            <tag> 莫队 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>可持久化线段树（主席树）</title>
      <link href="/2018/07/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89/"/>
      <url>/2018/07/24/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91%EF%BC%88%E4%B8%BB%E5%B8%AD%E6%A0%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<h1 id="不支持修改"><a href="#不支持修改" class="headerlink" title="不支持修改"></a>不支持修改</h1><p>读以下文字时最好有些线段树的预备知识，毕竟根据发明者的原话：“想法是对原序列的每一个前缀[1..i]建立出一颗线段树维护值域上每个数的出现次数，然后发现这样的树是可以减的，然后就没有然后了”</p><p>主席树可以用来解决如下问题：“给出一列数,a1,a2…an,每次询问其中连续的一段区间ai到aj其中的第K大的数是多少？”</p><p>建那么多的线段树显然会MLE！！但是为了便于理解，这里先把这个岔放下。我们先新开一个数组t[n]，其中存着an排序并去重的值。</p><p>那么每棵线段树维护的内容是什么呢？是a1到ai这段区间中的数在t[n]中出现的次数。这段话的内容也许有点抽象，举个例子 </p><p>an：4 1 1 2 8 9 4 4 3</p><p>排序并去重后得到{tn}</p><p>tn：1 2 3 4 8 9</p><p>下面对前缀a[1..9]建树，它有两个1,一个2,一个3，三个4，一个8和一个9，那么它的出现次数便是线段树维护的值（为表示清楚记为Cn）建树完后如下图，树中每个节点的值表示t[i,j]中的数字在a[1..9]中出现的次数和，i，j即为节点下面标出的区间。</p><p><img src="http://a3.qpic.cn/psb?/V137oTmC2F4y9l/2S3fUDKdnVKID0gupBH2P.rYvp02fQ93VsDePDGXLRY!/m/dCIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=0wFRAdMBUQEBACc!&amp;vuin=1013006824&amp;tm=1520676000&amp;sce=60-4-3&amp;rf=0-0" alt=""></p><p>下面我们来看对于这棵树如何求第K大值。比如我们求a[1..9]中第6大的数是多少？我们看到根节点的左儿子只有4个元素，那么第6大数一定在右儿子中，并且我们可以把问题递归下去即求区间t[4,6]的三个数中为a[1..9]去除所有数字为t[1],t[2],t[3]后第2大的数是多少。（c[1]+c[2]+c[3]=4，那么6-4=2）。我们看到此时的左儿子（区间t[4,5]）有4个元素，4&gt;2,因此第二大数一定在左儿子中，递归进入左儿子，此时即求区间t[4,5]的两个数中为a[1..9]去除所有数字为t[1],t[2],t[3],t[6]后第2大的数是多少。最后区间[4,4]有三个元素，3&gt;2，所以第二大数一定在区间[4,4]里即t[4]=4，所以a[1..9]中第6大数为4。</p><p>这里要记住的是对于每个i , a[1,i]都有一棵树，求a[L,R]的第K大与求a[1,R]的类似，只要在每层递归时减去a[1，L-1]所在树的相应部分即可，比如在a[L,R]，小于t[mid]的数有6个，在a[1,L-1] 小于t[mid]的数有2个，那么在a[L,R] 小于t[mid]的数就有6-2=4个，递归过程和上面类似，不再详细展开。</p><p>下面解决MLE这个梗。如下图画出a1…5到9为前缀的树，然后发现树的形态都非常像！！</p><p>例子 </p><p>an：4 1 1 2 8 9 4 4 3</p><p>排序并去重后得到{tn}</p><p>tn：1 2 3 4 8 9</p><p> <img src="http://a3.qpic.cn/psb?/V137oTmC2F4y9l/2S3fUDKdnVKID0gupBH2P.rYvp02fQ93VsDePDGXLRY!/m/dCIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=0wFRAdMBUQEBACc!&amp;vuin=1013006824&amp;tm=1520676000&amp;sce=60-4-3&amp;rf=0-0" alt=""></p><p> <img src="http://a3.qpic.cn/psb?/V137oTmC2F4y9l/AnbpwRjcYkCKVoDZhnI4H38uJ1bnNO690XauRZmZ5t0!/m/dCIBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=2wFsAdsBbAEBACc!&amp;vuin=1013006824&amp;tm=1520676000&amp;sce=60-4-3&amp;rf=0-0" alt=""></p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/a7IbaB.7jbVJfyDC6mBSH3JC1QXxu1ClfFQEn2vF9KA!/c/dCEBAAAAAAAA&amp;bo=0wFRAdMBUQEBACc!&amp;rf=mood_app" alt=""></p><p><img src="http://b289.photo.store.qq.com/psb?/V137oTmC2F4y9l/EOvrw6WLtcyvuNHLSBzUYTiYDtTyTpZTd6lM9IVDFJY!/c/dCEBAAAAAAAA&amp;bo=0wFRAdMBUQEBACc!&amp;rf=mood_app" alt=""></p><p>这是我们能够压缩的空间。例如以a[1..9]为前缀建的树的右子树与以a[1..8]为前缀建的树的右子树是相同的！！因此在建树a[1..9]的时候（建树是从1到9的顺序）根节点可以直接向a[1..8]的右子树连一条边。同理，对于根节点的左儿子来说（现在把这个点看做根节点），它的左子树和a[1..8]的相应部分也是相同的，因此也连一条边，如下图所示</p><p> <img src="http://b290.photo.store.qq.com/psb?/V137oTmC2F4y9l/1dG0ZdwBCVWhD.OSkmHQMKFOrQJIPIpz.BAOfgBD8ss!/c/dCIBAAAAAAAA&amp;bo=9wDTAPcA0wABACc!&amp;rf=mood_app" alt=""></p><p>这样我们只增加了三个点却保存了两棵树的所有信息！！像这样在前面树的基础上建树，我们只需要开一个数组储存图示两个箭头所指的根的位置就够了，顺着根向下遍历便是如前所述一棵完整的线段树</p><hr><h2 id="以下是瞎扯"><a href="#以下是瞎扯" class="headerlink" title="以下是瞎扯"></a>以下是瞎扯</h2><p>首先我们来了解什么叫做主席树，下面是从其他大佬的博客中复制过来的了解一下就行</p><p>所谓主席树呢，就是对原来的数列[1..n]的每一个前缀[1..i]（1≤i≤n）建立一棵线段树，线段树的每一个节点存某个前缀[1..i]中属于区间[L..R]的数一共有多少个（比如根节点是[1..n]，一共i个数，sum[root] = i；根节点的左儿子是[1..(L+R)/2]，若不大于(L+R)/2的数有x个，那么sum[root.left] = x）。若要查找[i..j]中第k大数时，设某结点x，那么x.sum[j] - x.sum[i - 1]就是[i..j]中在结点x内的数字总数。而对每一个前缀都建一棵树，会MLE，观察到每个[1..i]和[1..i-1]只有一条路是不一样的，那么其他的结点只要用回前一棵树的结点即可，时空复杂度为O(nlogn)。</p><hr><p>看了什么的介绍，感觉并没有什么卵用，还是一脸懵逼，下面我一点一点来讲解主席树的原理以及实现过程和代码。</p><p>在学习主席树之前，需要你很熟悉线段树这个东西，因为主席树的主体是多颗线段树，首先我们来简单的回顾一下线段树的简单特点和性质，我们熟悉的线段树一般是用一个结构体表示一个节点，每个节点有一个编号，节点里面一般有两个变量l, r来表示这个节点维护的区间，然后还有一个区间信息（比如区间最大值，最小值，和等，视具体问题而定），当然如果涉及到区间更新，还有一个add或者lazy叫做延迟标记的东西，然后一般线段树最明显的特点就行，一个父节点的编号是i,那么他的两只儿子节点的编号分别为2 <em> i(左） , 2 </em> i + 1（右），注意主席树在这一点有别于一般的线段树，每一个父节点，他的两个儿子节点的编号不一定满足这个关系。</p><p>我们先来分析一下对于任意一个区间，我们怎样求解这个区间的第k小值，当然一个最简单的做法就是把这个区间的数都拿出来排个序，然后直接输出就好，这很简单，但是复杂度爆表，我们考虑一个线段树的做法，假如一个区间l, r我们用一个用这个区间内出现过的数的个数组成一颗线段树，这是什么意思呢，求一个区间的第k小数，当然与这个区间有多少数比他小有关，在这里我举一个例子来说明一下怎样建立这样的一颗线段树。比如这个区间表示的序列是4，1，3，2，我们要求第2小，我们一眼就看出是2，那么我们怎样上面所说的线段树来求解呢，下面我画了一幅图来讲解，其中这颗线段树上的每个节点维护的是这个节点表示区间内的个数（假设每个数都不一样）</p><p> <img src="http://b247.photo.store.qq.com/psb?/V137oTmC2F4y9l/ca0YRv9fRBOPR7nmbKhIbHOCb*RSMmykiARFerbHLgc!/c/dPcAAAAAAAAA&amp;bo=QQLaAUEC2gEBACc!&amp;rf=mood_app" alt=""></p><p>圈内的数字表示这个区间里面有多少个数，最后叶节点表示一个数字，对应上述序列中的一个数，注意，任意一个长度为N的序列我们都可以把他离散为一个1 ，2，3，，，，N的序列，只需要简单的hash一下就行。然后这样的一颗线段树建立出来了，我们怎样寻找区间第2小，因为叶节点从左到右表示的数依次增大，根据这个性质，以及每个节点保存了区间内的数的个数这个信息，我们可以轻易的找出区间第2小，具体的找法是，从根节点开始，看左儿子里面的数的 个数是不是大于等于2，如果是则第2小一定在左子树中，于是继续找左子树，反之找右子树，直到找到叶节点为止，然后直接返回叶节点表示的值就行。</p><p>但是多次询问区间第k小，我们每次这样建立一个线段树，这样不仅空间复杂度非常之高，而且时间复杂度也非常高，甚至比普通排序还要高，那么我们只不是可以想一个办法，使得对于每次我们查询不同的区间我们不需要重新建树，如果这样。时间复杂度和空间复杂度就大大降低了。</p><p>我们很容易就联想到了前缀和的概念，比如我们有一个问题。就是每次静态的求区间和，我们可以预处理所以的前缀和sum[i]，我们每次求解区间l, r和时，我们可以直接得到答案为sum[r] - sum[l -1],这样就不需要对区间中的每个数进行相加来求解了。</p><p>同样一个道理，我们也可以利用前缀和这个思想来解决建树这个问题，我们只需要建立n颗“前缀”线段树就行，第i树维护[1,i]序列，这样我们处理任意区间l, r时就可以通过处理区间[1,l - 1], [1,r]，就行，然后两者的处理结果进行相加相减就行。为什么满足相加减的性质，我们简单分析一下就很容易得出。如果在区间[1,l - 1]中有x个数小于一个数，在[1,r]中有y个数小于那个数，那么在区间[l,r]中就有y - x 个数小于那个数了，这样就很好理解为什么可以相加减了，另外，每颗树的结构都一样，都是一颗叶节点为n个的线段树。</p><p>上述利用前缀和的思想只是解决了时间复杂度的问题，并没有解决空间复杂度的问题，要解决空间复杂度问题。我们需要用到线段树的性质，我们每次更新一个数，那么与更新之前相比，这颗线段树改变只是一条链（从根节点到某一叶节点），那么我们可以充分利用这个特点，因为第i颗树与第i- 1颗树相比，只是更新了第i个元素，所以这两棵树有很多相同的节点，所以这两棵树可以共用很多节点（这也是为什么主席树的中节点编号不满足儿子节点编号是父节点编号的两倍和两倍加一的原因），于是这样就解决空间复杂度问题。</p><p><a href="https://www.luogu.org/problemnew/show/P3919" target="_blank" rel="noopener"> P3919 【模板】可持久化数组（可持久化线段树/平衡树）</a></p><p>手写AC（O2-1016ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200000+110using namespace std;int a[N],Hash[N],t[N],tot,n,m;int sum[50*N],L[50*N],R[50*N];int build(int l,int r){    int rt=++tot;    sum[rt]=0;    if(l&lt;r)    {        int m=(l+r)/2;        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}int update(int pre,int l,int r,int x){    int rt=++tot;    L[rt]=L[pre];    R[rt]=R[pre];    sum[rt]=sum[pre]+1;    if(l&lt;r)    {        int m=(l+r)/2;        if(x&lt;=m)            L[rt]=update(L[pre],l,m,x);        else            R[rt]=update(R[pre],m+1,r,x);    }    return rt;}int query(int u,int v,int l,int r,int k){    if(l==r)        return l;    int num=sum[L[v]]-sum[L[u]];    int m=(l+r)/2;    if(num&gt;=k)        return query(L[u],L[v],l,m,k);    else        return query(R[u],R[v],m+1,r,k-num);}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        Hash[i]=a[i];    }    sort(Hash+1,Hash+1+n);    int d=unique(Hash+1,Hash+1+n)-Hash-1;    t[0]=build(1,d);    for(int i=1;i&lt;=n;i++)    {        int x=lower_bound(Hash+1,Hash+1+d,a[i])-Hash;        t[i]=update(t[i-1],1,d,x);    }    for(int i=1;i&lt;=m;i++)    {        int l,r,k;        scanf(&quot;%d%d%d&quot;,&amp;l,&amp;r,&amp;k);        int x=query(t[l-1],t[r],1,d,k);        printf(&quot;%d\n&quot;,Hash[x]);    }    return 0;}</code></pre><p><a href="https://www.luogu.org/problemnew/show/P3567" target="_blank" rel="noopener">P3567 [POI2014]KUR-Couriers</a></p><p>手写AC（O2-1032ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500000+110using namespace std;int a[N],Hash[N],t[N],tot,n,m;int sum[50*N],L[50*N],R[50*N];int build(int l,int r){    int rt=++tot;    sum[rt]=0;    if(l&lt;r)    {        int m=(l+r)/2;        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}int update(int pre,int l,int r,int x){    int rt=++tot;    L[rt]=L[pre];    R[rt]=R[pre];    sum[rt]=sum[pre]+1;    if(l&lt;r)    {        int m=(l+r)/2;        if(x&lt;=m)            L[rt]=update(L[pre],l,m,x);        else            R[rt]=update(R[pre],m+1,r,x);    }    return rt;}int query(int u,int v,int l,int r,int k){    if(l==r)        return l;    int num=sum[L[v]]-sum[L[u]];    int num1=sum[R[v]]-sum[R[u]];    int m=(l+r)/2;    if(num&gt;=k)        return query(L[u],L[v],l,m,k);    else if(num1&gt;=k)        return query(R[u],R[v],m+1,r,k);    else        return 0;}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        Hash[i]=a[i];    }    sort(Hash+1,Hash+1+n);    int d=unique(Hash+1,Hash+1+n)-Hash-1;    t[0]=build(1,d);    for(int i=1;i&lt;=n;i++)    {        int x=lower_bound(Hash+1,Hash+1+d,a[i])-Hash;        t[i]=update(t[i-1],1,d,x);    }    for(int i=1;i&lt;=m;i++)    {        int l,r,k;        scanf(&quot;%d%d&quot;,&amp;l,&amp;r);        k=(r-l+1)/2+1;        int x=query(t[l-1],t[r],1,d,k);        printf(&quot;%d\n&quot;,Hash[x]);    }    return 0;}</code></pre><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=4417" target="_blank" rel="noopener">HDU 4417 Super Mario</a></p><p>纯手写AC（140ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500000+110#define inf 2147483647using namespace std;int a[N],Hash[N];int sum[50*N],L[50*N],R[50*N],t[N],tot,n,m;int build(int l,int r){    int rt=++tot;    sum[rt]=0;    if(l&lt;r)    {        int m=(l+r)/2;        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}int update(int pre,int l,int r,int x){    int rt=++tot;    L[rt]=L[pre];    R[rt]=R[pre];    sum[rt]=sum[pre]+1;    if(l&lt;r)    {        int m=(l+r)/2;        if(x&lt;=m)            L[rt]=update(L[pre],l,m,x);        else            R[rt]=update(R[pre],m+1,r,x);    }    return rt;}int query(int u,int v,int l,int r,int k){    if(l==r)        return sum[v]-sum[u];    int b=0;    int m=(l+r)/2;    if(k&gt;m)    {        b+=sum[L[v]]-sum[L[u]];        b+=query(R[u],R[v],m+1,r,k);    }    else        b+=query(L[u],L[v],l,m,k);    return b;}int main(){    int T;    scanf(&quot;%d&quot;,&amp;T);    for(int j=1;j&lt;=T;j++)    {        tot=0;        printf(&quot;Case %d:\n&quot;,j);        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);        for(int i=1;i&lt;=n;i++)        {            scanf(&quot;%lld&quot;,&amp;a[i]);            Hash[i]=a[i];        }        sort(Hash+1,Hash+1+n);        int d=unique(Hash+1,Hash+1+n)-Hash-1;        Hash[++d]=inf;        t[0]=build(1,d);        for(int i=1;i&lt;=n;i++)        {            int x=lower_bound(Hash+1,Hash+1+d,a[i])-Hash;            t[i]=update(t[i-1],1,d,x);        }        for(int i=1;i&lt;=m;i++)        {            int l,r;            long long h;            scanf(&quot;%d%d%lld&quot;,&amp;l,&amp;r,&amp;h);            l++;            r++;            int ans=0;            int k=upper_bound(Hash+1,Hash+1+d,h)-Hash-1;            if(k&gt;0)                ans=query(t[l-1],t[r],1,d,k);            printf(&quot;%d\n&quot;,ans);        }    }    return 0;}</code></pre><h1 id="带修改（主席树-树状数组）"><a href="#带修改（主席树-树状数组）" class="headerlink" title="带修改（主席树+树状数组）"></a>带修改（主席树+树状数组）</h1><p><a href="https://www.luogu.org/problemnew/show/P2617" target="_blank" rel="noopener"> P2617 Dynamic Rankings</a></p><p>题意：n个数，q个询问 (n&lt;=50000, q&lt;=10000)</p><p>Q x y z 代表询问[x, y]区间里的第z小的数</p><p>C x y    代表将(从左往右数)第x个数变成y</p><p>上篇介绍了在[x, y]区间内查询第z小的数的方法(静态主席树)</p><p>本题有更新操作</p><p>若仍用上篇的做法，每次更新一个数，需要更新的是T[i], T[i+1]… …T<a href="该数所在的树以及它后面的所有树">n</a>，因为每棵树T[i]所记录的都是前缀(1到i的数出现的次数) 因此，改变i，会影响i到n的所有树</p><p>这样，每次更新的复杂度最坏为O(nn)，最坏更新q次即为O(n×mn×m) 复杂度相当庞大，很明显这样做是不行的</p><p>那怎么办呢？</p><p>我们可以发现，对于改变i处的数这个操作，对于T[i], T[i+1]… …T[n]这些树的影响是相同的，都只改变了  “原来i处的数 的数量”  和  “现在i处的数 的数量” 这两个值而已，我们只要在原来的基础上增加一类树， 用它们来维护更新掉的数，即用树状数组来记录更新，每次更新lognlogn棵树。</p><p>下面来演示一下建树到查询的过程：</p><p>比如此题的第一个案例</p><p>5 33 2 1 4 7</p><p>Q 1 4 3</p><p>C 2 6</p><p>Q 2 5 3</p><p>先将序列以及要更新的数(C操作)离散化  </p><p>即3 2 1 4 7 、 6  ——&gt;(排序) ——&gt; 1 2 3 4 6 7  </p><p>那么我们就需要建一棵这样的树：</p><p><img src="https://qqadapt.qpic.cn/txdocpic/0/f2402af8499c21a706cefa1d4f0a81b4/0" alt=""></p><p>(圈里的都是结点的编号， 4、5、6、9、10、11号结点代表的分别是1、2、3、4、6、7)</p><p>(4、5、9、10你也可以任意作为6或11的儿子， 递归生成的是类似这样的， 这并不重要)</p><p>对于3 2 1 4 7(先不管需要更新的6)建完树见下图(建树过程同静态的，不明白的请向上翻)</p><p><img src="https://qqadapt.qpic.cn/txdocpic/0/543df959260eef02bae09abae5a3d88a/0" alt=""></p><p>(红色的是个数， 相同结点的个数省略了，同前一棵树)</p><p>对于C操作之前的Q，就跟静态的类似，减一减 找就好了</p><p>然后下面要更新了</p><p>对于更新， 我们不改变这些已经建好的树， 而是另建一批树S，用来记录更新，而这批线段树，我们用树状数组来维护</p><p>也就是树状数组的每个节点都是一颗线段树</p><p>一开始，S[0]、S[1]、S[2]、S[3]、S[4]、S<a href="树状数组的每个节点">5</a>这些都与T[0]相同(也就是每个节点建了一棵空树)</p><p>对于C 2 6 这个操作， 我们只需要减去一个2，加上一个6即可</p><p>对于减去2</p><p>(树状数组i+lowbit(i)为i的父亲节点， 修改i，就要把i的所有父亲节点都修改了)</p><p>2在树状数组中出现的位置是 2、2+lowbit(2)=4 这两个位置，    </p><p>因此要更新的是S[2]和S[4]这两个节点中的树</p><p>删去2后是这样</p><p><img src="https://qqadapt.qpic.cn/txdocpic/0/e095409f1ad1dc184f7c2e530eb56dda/0" alt=""></p><p>加上一个6 (同样是对于2号位置， 因此需要更新的仍是S[2]和S[4])</p><p>加上之后是这样</p><p> <img src="https://qqadapt.qpic.cn/txdocpic/0/31b1e6754c984e4ae70179d0b02dacdd/0" alt=""></p><p> 当查询的时候， 对树T的操作与静态的一致，另外再加上S树的值就好了</p><p>教练的模板</p><pre><code class="lang-cpp">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdlib&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#define N 60000+5//空间为nlogn*lognusing namespace std;struct node{    int l;    int r;    int flag;    int k;}q[N];int a[N],Hash[2*N],L[32*N],R[32*N],sum[32*N],s[32*N],T[32*N],n,m,dd,tot,use[32*N];int lowbit(int x){return x&amp;(-x);}int getsum(int x){    int ret=0;    while(x&gt;0)    {        ret+=sum[L[use[x]]];        x-=lowbit(x);    }    return ret;}int build(int l,int r){    int rt=++tot;    int m=(l+r)/2;    if(l&lt;r)    {        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}int update(int pre,int l,int r,int x,int d){    int rt=++tot;    L[rt]=L[pre];R[rt]=R[pre];sum[rt]=sum[pre]+d;    if(l&lt;r)    {        int m=(l+r)/2;        if(x&lt;=m)            L[rt]=update(L[pre],l,m,x,d);        else            R[rt]=update(R[pre],m+1,r,x,d);    }    return rt;}int query(int u,int v,int ll,int rr,int l,int r,int k){    if(l&gt;=r)return l;    int m=(l+r)/2;    int aa=getsum(v);    int bb=getsum(u);    int num=aa-bb+sum[L[rr]]-sum[L[ll]];    if(k&lt;=num)    {        for(int j=u;j&gt;0;j=j-lowbit(j))use[j]=L[use[j]];        for(int j=v;j&gt;0;j=j-lowbit(j))use[j]=L[use[j]];        return query(u,v,L[ll],L[rr],l,m,k);    }    else    {        for(int j=u;j&gt;0;j=j-lowbit(j))use[j]=R[use[j]];        for(int j=v;j&gt;0;j=j-lowbit(j))use[j]=R[use[j]];        return query(u,v,R[ll],R[rr],m+1,r,k-num);    }}void modify(int x,int p,int d){    while(x&lt;=n)    {        s[x]=update(s[x],1,dd,p,d);        x+=lowbit(x);    }}int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    int d=0;    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        Hash[++d]=a[i];    }    char ss[5];    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%s&quot;,ss);        if(ss[0]==&#39;Q&#39;)        {            scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);            q[i].flag=1;        }        else        {            scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);            Hash[++d]=q[i].r;            q[i].flag=0;        }    }    sort(Hash+1,Hash+1+d);    dd=unique(Hash+1,Hash+1+d)-Hash-1;    T[0]=build(1,dd);    for(int i=1;i&lt;=n;i++)    {        int x=lower_bound(Hash+1,Hash+1+dd,a[i])-Hash;        T[i]=update(T[i-1],1,dd,x,1);    }    for(int i=1;i&lt;=n;i++)s[i]=T[0];    for(int i=1;i&lt;=m;i++)    {        if(q[i].flag)        {            for(int j=q[i].l-1;j&gt;0;j=j-lowbit(j))use[j]=s[j];            for(int j=q[i].r;j&gt;0;j=j-lowbit(j))use[j]=s[j];            int t=query(q[i].l-1,q[i].r,T[q[i].l-1],T[q[i].r],1,dd,q[i].k);            printf(&quot;%d\n&quot;,Hash[t]);        }        else        {            int xx=lower_bound(Hash+1,Hash+1+dd,a[q[i].l])-Hash;            int yy=lower_bound(Hash+1,Hash+1+dd,q[i].r)-Hash;            modify(q[i].l,xx,-1);            modify(q[i].l,yy,1);            a[q[i].l]=q[i].r;        }    }    return 0;}</code></pre><p>手写AC（对拍O2-96ms）</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 60010using namespace std;struct node{    int l,r,flag,k;};struct node q[N];int a[N],Hash[2*N],L[32*N],R[32*N],sum[32*N],s[32*N],T[32*N],n,m,dd,tot,use[32*N];inline int lowbit(int x){    return x&amp;(-x);}inline int getsum(int x){    int ret=0;    while(x&gt;0)    {        ret+=sum[L[use[x]]];        x-=lowbit(x);    }    return ret;}inline int build(int l,int r){    int rt=++tot;    int m=(l+r)&gt;&gt;1;    if(l&lt;r)    {        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}inline int update(int pre,int l,int r,int x,int d){    int rt=++tot;    L[rt]=L[pre];    R[rt]=R[pre];    sum[rt]=sum[pre]+d;    if(l&lt;r)    {        int m=(l+r)&gt;&gt;1;        if(x&lt;=m)            L[rt]=update(L[pre],l,m,x,d);        else            R[rt]=update(R[pre],m+1,r,x,d);    }    return rt;}inline int query(int u,int v,int left,int right,int l,int r,int k){    if(l&gt;=r)        return l;    int m=(l+r)&gt;&gt;1;    int aa=getsum(v);    int bb=getsum(u);    int num=aa-bb+sum[L[right]]-sum[L[left]];    if(k&lt;=num)    {        for(register int j=u;j&gt;0;j-=lowbit(j))            use[j]=L[use[j]];        for(register int j=v;j&gt;0;j-=lowbit(j))            use[j]=L[use[j]];        return query(u,v,L[left],L[right],l,m,k);    }    else    {        for(register int j=u;j&gt;0;j-=lowbit(j))            use[j]=R[use[j]];        for(register int j=v;j&gt;0;j-=lowbit(j))            use[j]=R[use[j]];        return query(u,v,R[left],R[right],m+1,r,k-num);    }}inline void modify(int x,int p,int d){    while (x&lt;=n)    {        s[x]=update(s[x],1,dd,p,d);        x+=lowbit(x);    }}int main(){    scanf(&quot;%d%d&quot;,&amp;n,&amp;m);    int d=0;    for(register int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;a[i]);        Hash[++d]=a[i];    }    char ss[5];    for(register int i=1;i&lt;=m;i++)    {        scanf(&quot;%s&quot;,ss);        if(ss[0]==&#39;Q&#39;)        {            scanf(&quot;%d%d%d&quot;,&amp;q[i].l,&amp;q[i].r,&amp;q[i].k);            q[i].flag=1;        }        else        {            scanf(&quot;%d%d&quot;,&amp;q[i].l,&amp;q[i].r);            Hash[++d]=q[i].r;            q[i].flag=0;        }    }    sort(Hash+1,Hash+1+d);    dd=unique(Hash+1,Hash+1+d)-Hash-1;    T[0]=build(1,dd);    for(register int i=1;i&lt;=n;i++)    {        int x=lower_bound(Hash+1,Hash+1+dd,a[i])-Hash;        T[i]=update(T[i-1],1,dd,x,1);    }    for(register int i=1;i&lt;=n;i++)        s[i]=T[0];    for(register int i=1;i&lt;=m;i++)    {        if(q[i].flag)        {            for(register int j=q[i].l-1;j&gt;0;j-=lowbit(j))                use[j]=s[j];            for(register int j=q[i].r;j&gt;0;j-=lowbit(j))                use[j]=s[j];            int t=query(q[i].l-1,q[i].r,T[q[i].l-1],T[q[i].r],1,dd,q[i].k);            printf(&quot;%d\n&quot;,Hash[t]);        }        else        {            int xx=lower_bound(Hash+1,Hash+1+dd,a[q[i].l])-Hash;            int yy=lower_bound(Hash+1,Hash+1+dd,q[i].r)-Hash;            modify(q[i].l,xx,-1);            modify(q[i].l,yy,1);            a[q[i].l]=q[i].r;        }    }    return 0;}</code></pre><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><a href="https://www.luogu.org/problemnew/show/P1383" target="_blank" rel="noopener">P1383 高级打字机</a></p><p>手写AC</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 500010using namespace std;int a[N*32],L[32*N],R[32*N],sum[32*N],T[32*N],n,m,tot,cnt,use[32*N],root[32*N];inline int Insert(int pre,int l,int r,int p,int x){    int rt=++tot;    if(l==r)    {        a[rt]=x;        sum[rt]=sum[pre]+1;        return rt;    }    L[rt]=L[pre];    R[rt]=R[pre];    sum[rt]=sum[pre]+1;    int m=(l+r)&gt;&gt;1;    if(p&lt;=m)        L[rt]=Insert(L[pre],l,m,p,x);    else        R[rt]=Insert(R[pre],m+1,r,p,x);    return rt;}inline int build(int l,int r){    int rt=++tot;    int m=(l+r)&gt;&gt;1;    if(l&lt;r)    {        L[rt]=build(l,m);        R[rt]=build(m+1,r);    }    return rt;}inline int query(int p,int l,int r,int x){    if(l==r)        return a[p];    int m=(l+r)&gt;&gt;1;    if(x&lt;=sum[L[p]])        return query(L[p],l,m,x);    else        return query(R[p],m+1,r,x-sum[L[p]]);}int main(){    scanf(&quot;%d&quot;,&amp;n);    root[0]=build(1,n);    char ss[5];    for(register int i=1;i&lt;=n;i++)    {        scanf(&quot;%s&quot;,ss);        if(ss[0]==&#39;T&#39;)        {            char ch;            scanf(&quot;%s&quot;,&amp;ch);            int x=ch-&#39;a&#39;+1;            root[++cnt]=Insert(root[cnt-1],1,n,i,x);        }        else if(ss[0]==&#39;U&#39;)        {            int x;            scanf(&quot;%d&quot;,&amp;x);            root[++cnt]=root[cnt-x-1];        }        else        {            int x;            scanf(&quot;%d&quot;,&amp;x);            char ch=query(root[cnt],1,n,x)+&#39;a&#39;-1;            printf(&quot;%c\n&quot;,ch);        }    }    return 0;}</code></pre>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>平衡树</title>
      <link href="/2018/07/24/%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
      <url>/2018/07/24/%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>这里讲两种解法：Splay和FHQ Treap</p><h3 id="首先是Splay"><a href="#首先是Splay" class="headerlink" title="首先是Splay"></a>首先是Splay</h3><p>我们知道，Splay是一种树形结构，它具有二叉搜索树的性质，维护树上的节点有序，即对于某一节点，它的左子树中所有节点的值都小于这个点，它的右子树中所有点的值都大于这个点。</p><p>然后就是Splay中的重点操作，Rotate。我们都知道Splay的复杂度之所以维持在logn级别与旋转操作有着很大的关系，旋转分为两种：左旋和右旋。旋转见图示（感谢<a href="https://www.cnblogs.com/yousiki/p/6147455.html" target="_blank" rel="noopener">You Siki</a>的图片）<br><img src="http://img.my.csdn.net/uploads/201210/10/1349877565_2986.png" alt=""></p><p>然后为了将某个值旋转至树根便于操作，又有了3种操作：Zig、Zig-Zig、Zig-Zag。具体见图示<br><img src="http://img.my.csdn.net/uploads/201210/10/1349877709_4105.png" alt=""><img src="http://img.my.csdn.net/uploads/201210/10/1349877744_7090.png" alt=""><img src="http://img.my.csdn.net/uploads/201210/10/1349877779_5253.png" alt=""></p><p>然后是各种简单操作（Search等较简单的，人人都会的我就不讲了）</p><pre><code class="lang-cpp">void Rotate(int x){    int y=fa[x];    int z=fa[y];    if(child[z][0]==y)        child[z][0]=x;    else        child[z][1]=x;    fa[x]=z;    int w;    if(child[y][0]==x)        w=0;    else        w=1;    child[y][w]=child[x][w^1];    fa[child[x][w^1]]=y;    child[x][w^1]=y;    fa[y]=x;    ct[y]=ct[child[y][0]]+ct[child[y][1]]+num[y];    ct[x]=ct[child[x][0]]+ct[child[x][1]]+num[x];}void splay(int x){    while(fa[x])    {        int y=fa[x];        int z=fa[y];        if(z==0)            Rotate(x);        else        {            if((child[z][0]==y)^(child[y][0]==x))                Rotate(x);            else                Rotate(y);            Rotate(x);        }    }    root=x;}</code></pre><p>Splay和Rotate，这两个是整个Splay的核心函数，请自行参照图示去理解（注：splay函数里的if语句用于判定Zig还是Zag</p><pre><code class="lang-cpp">void Insert(int x){    if(tot==0)    {        tot=1;        a[1]=x;        num[1]=1;        root=1;        ct[1]=1;        fa[1]=0;        return;    }    int k=Search(root,x);    int node=0;    if(a[k]==x)    {        num[k]++;        node=k;    }    else    {        ++tot;        a[tot]=x;        num[tot]=1;        ct[tot]=1;        fa[tot]=k;        if(x&lt;a[k])            child[k][0]=tot;        else            child[k][1]=tot;    }    while(k)    {        ct[k]++;        k=fa[k];    }    if(node)        splay(node);    else        splay(tot);}</code></pre><p>Insert其实比较规矩，就是找到一个与这个值相近的点（一定是叶子节点），然后判断一下x与a[k]的大小关系，如果比a[k]大就接到右子树，比a[k]小就接到左子树。</p><pre><code>void Delete(int x){    int k=Search(root,x);    if(a[k]!=x)        splay(k);    else    {        splay(k);        if(num[k]&gt;1)        {            num[k]--;            ct[k]--;        }        else        {            if(child[k][0]==0)            {                root=child[k][1];                fa[root]=0;                a[k]=MIN;                num[k]=0;                ct[k]=0;                child[k][0]=0;                child[k][1]=0;            }            else            {                fa[child[k][0]]=0;                int kk=Search(child[k][0],2147483647);                splay(kk);                ct[root]+=ct[child[k][1]];                child[root][1]=child[k][1];                fa[child[k][1]]=root;                a[k]=MIN;                num[k]=0;                ct[k]=0;                child[k][0]=0;                child[k][1]=0;            }        }    }}</code></pre><p>Delete其实算是比较烦的了，分了四种情况，前两种比较简单，主要是后两种。如果要删除的节点没有左子树，就直接把该节点删除，根节点变为右儿子；如果有，就先切断该节点与左儿子的连接，然后将左子树中的最大值旋转到左子树的根，然后将右子树接到左子树的右边。</p><p>Rank和Find比较简单，这里不讲</p><pre><code class="lang-cpp">int pre(int x){    int k=Search(root,x);    splay(k);    if(a[k]&lt;x)        return a[k];    int kk=Search(child[k][0],2147483647);    splay(kk);    return a[kk];}int succ(int x){    int k=Search(root,x);    splay(k);    if(a[k]&gt;x)        return a[k];    int kk=Search(child[k][1],-2147483647);    splay(kk);    return a[kk];}</code></pre><p>pre（前驱）和succ（后缀）的思路基本相同，都是先将要找的值（如果有的话）旋转到根，然后pre是在左子树中找最大值，succ是在右子树中找最小值</p><p>以下是合代码</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 100000+110#define MIN -1e8using namespace std;int child[N][2],fa[N],a[N],ct[N],num[N];int n,tot,root;int Search(int x,int w){    if(a[x]==w)        return x;    while(a[x]!=w)    {        if(a[x]&gt;w)        {            if(child[x][0])                x=child[x][0];            else                break;        }        else if(a[x]==w)            return x;        else        {            if(child[x][1])                x=child[x][1];            else                break;        }    }    return x;}void Rotate(int x){    int y=fa[x];    int z=fa[y];    if(child[z][0]==y)        child[z][0]=x;    else        child[z][1]=x;    fa[x]=z;    int w;    if(child[y][0]==x)        w=0;    else        w=1;    child[y][w]=child[x][w^1];    fa[child[x][w^1]]=y;    child[x][w^1]=y;    fa[y]=x;    ct[y]=ct[child[y][0]]+ct[child[y][1]]+num[y];    ct[x]=ct[child[x][0]]+ct[child[x][1]]+num[x];}void splay(int x){    while(fa[x])    {        int y=fa[x];        int z=fa[y];        if(z==0)            Rotate(x);        else        {            if((child[z][0]==y)^(child[y][0]==x))                Rotate(x);            else                Rotate(y);            Rotate(x);        }    }    root=x;}void Insert(int x){    if(tot==0)    {        tot=1;        a[1]=x;        num[1]=1;        root=1;        ct[1]=1;        fa[1]=0;        return;    }    int k=Search(root,x);    int node=0;    if(a[k]==x)    {        num[k]++;        node=k;    }    else    {        ++tot;        a[tot]=x;        num[tot]=1;        ct[tot]=1;        fa[tot]=k;        if(x&lt;a[k])            child[k][0]=tot;        else            child[k][1]=tot;    }    while(k)    {        ct[k]++;        k=fa[k];    }    if(node)        splay(node);    else        splay(tot);}void Delete(int x){    int k=Search(root,x);    if(a[k]!=x)        splay(k);    else    {        splay(k);        if(num[k]&gt;1)        {            num[k]--;            ct[k]--;        }        else        {            if(child[k][0]==0)            {                root=child[k][1];                fa[root]=0;                a[k]=MIN;                num[k]=0;                ct[k]=0;                child[k][0]=0;                child[k][1]=0;            }            else            {                fa[child[k][0]]=0;                int kk=Search(child[k][0],2147483647);                splay(kk);                ct[root]+=ct[child[k][1]];                child[root][1]=child[k][1];                fa[child[k][1]]=root;                a[k]=MIN;                num[k]=0;                ct[k]=0;                child[k][0]=0;                child[k][1]=0;            }        }    }}int Rank(int x){    int k=Search(root,x);    splay(k);    return ct[child[k][0]]+1;}int Find(int x){    int k=root;    while(!(x&gt;=ct[child[k][0]]+1&amp;&amp;x&lt;=ct[child[k][0]]+num[k])&amp;&amp;k!=0)    {        if(x&gt;ct[child[k][0]]+num[k])        {            x-=ct[child[k][0]]+num[k];            k=child[k][1];        }        else            k=child[k][0];    }    return a[k];}int pre(int x){    int k=Search(root,x);    splay(k);    if(a[k]&lt;x)        return a[k];    int kk=Search(child[k][0],2147483647);    splay(kk);    return a[kk];}int succ(int x){    int k=Search(root,x);    splay(k);    if(a[k]&gt;x)        return a[k];    int kk=Search(child[k][1],-2147483647);    splay(kk);    return a[kk];}int main(){    scanf(&quot;%d&quot;,&amp;n);    memset(a,MIN,sizeof(a));    for(int i=1;i&lt;=n;i++)    {        int x,z;        scanf(&quot;%d%d&quot;,&amp;z,&amp;x);        switch(z)        {            case 1:Insert(x);break;            case 2:Delete(x);break;            case 3:printf(&quot;%d\n&quot;,Rank(x));break;            case 4:printf(&quot;%d\n&quot;,Find(x));break;            case 5:printf(&quot;%d\n&quot;,pre(x));break;            case 6:printf(&quot;%d\n&quot;,succ(x));break;        }    }    return 0;}</code></pre><p>AC记录</p><p><a href="https://www.luogu.org/record/show?rid=5888411" target="_blank" rel="noopener">用时: 380ms / 内存: 3488KB</a></p><h3 id="然后是FHQ-Treap"><a href="#然后是FHQ-Treap" class="headerlink" title="然后是FHQ Treap"></a>然后是FHQ Treap</h3><p>由于省去了Rotate的操作，非旋的Treap就显得极为简洁（鄙人Splay代码200+，FHQ Treap代码仅130+）。再加上它几乎可以实现Splay的全部功能（LCT除外），所以当然是选择FHQ Treap啦。（开讲之前先%一波FHQ</p><p>是不是觉得Splay也好，Treap也好，转来转去的很烦人呢？那么如果我们可以暴力的把区间切成两段（或三段），然后对其中某一段操作完后再合起来是不是会简单的多呢？来学FHQ Treap吧，这东西绝对对你胃口！</p><p>那么既然这个东西要把一个区间切成数段，就需要一个split，实际上它有两种分法：一种是把权值比k小的放入一颗树，比k大的放入另一颗树；另一种是把前k个点放入一棵树，其他的放入另一棵树。这里给出第一种的讲解。</p><pre><code class="lang-cpp">void split(int now,int k,int &amp;l,int &amp;r){    if(!now)        l=r=0;    else    {        if(a[now]&lt;=k)        {            l=now;            split(child[now][1],k,child[now][1],r);        }        else        {            r=now;            split(child[now][0],k,l,child[now][0]);        }        pushup(now);    }}</code></pre><p>对于我们遍历到每一个点，假如它的权值小于k，那么它的所有左子树，都要分到左边的树里，然后遍历它的右儿子。假如大于k，把它的所有右子树分到右边的树里，遍历左儿子。</p><p>因为它的最多操作次数就是一直分到底，效率就是O(logn)</p><p>接下来是合并的操作</p><pre><code class="lang-cpp">int Merge(int x,int y){    if(!x||!y)        return x+y;    if(pri[x]&lt;pri[y])    {        child[x][1]=Merge(child[x][1],y);        pushup(x);        return x;    }    else    {        child[y][0]=Merge(x,child[y][0]);        pushup(y);        return y;    }}</code></pre><p>因为第一个Treap的权值都比较小，我们比较一下它的tar(附加权值)，假如第一个的tar小，我们就可以直接保留它的所有左子树，接着把第一个Treap变成它的右儿子。反之，我们可以保留第二棵的所有右子树，指针指向左儿子。</p><p>你可以把这个过程形象的理解为在第一个Treap的左子树上插入第二个树，也可以理解为在第二个树的左子树上插入第一棵树。因为第一棵树都满足小于第二个树，所以就变成了比较tar来确定树的形态。</p><p>也就是说，我们其实是遍历了第一个Treap的根-&gt;最大节点，第二个Treap的根-&gt;最小节点，也就是O(logn)</p><p>然后对于Insert，就不过是一个按照x的权值分开，插入后再合并的的过程罢了，Delete就是把树按照x分成l和r,再把l按照x-1分成c,d。把c的两个子儿子合并起来，再和r合并。</p><p>找前驱的话把root按x-1分成l,r，在l里面找最大值；找后继的话把root按x分成l,r，在r里找最小值。</p><p>Rank就是把root按x-1分成l,r，排名就是ct[l]；Find的过程和Splay差别并不大，都不细讲。</p><p>值得注意的是，FHQ Treap的本质还是一个Treap，是将树上的值按rand值排序的，r值小的在上面，r值大的在下面。这也是为什么Treap（树堆）成为Treap。</p><p>部分搬运某dalao博客，详细讲解和split,Merge的GIF演示可参见<a href="http://www.yhzq-blog.cc/fhq-treap总结/" target="_blank" rel="noopener">远航之曲</a></p><p>（实际上第二个GIF最后一步合错了，9应该挂在8右边的）</p><p>以下是合代码</p><pre><code>#include &lt;bits/stdc++.h&gt;#define N 100010#define inf 2147483647using namespace std;int n,tot,root;int child[N][2],ct[N],a[N],pri[N];void pushup(int x){    ct[x]=1+ct[child[x][0]]+ct[child[x][1]];}int new_node(int x){    ct[++tot]=1;    a[tot]=x;    pri[tot]=rand();    return tot;}int Merge(int x,int y){    if(!x||!y)        return x+y;    if(pri[x]&lt;pri[y])    {        child[x][1]=Merge(child[x][1],y);        pushup(x);        return x;    }    else    {        child[y][0]=Merge(x,child[y][0]);        pushup(y);        return y;    }}void split(int now,int k,int &amp;l,int &amp;r){    if(!now)        l=r=0;    else    {        if(a[now]&lt;=k)        {            l=now;            split(child[now][1],k,child[now][1],r);        }        else        {            r=now;            split(child[now][0],k,l,child[now][0]);        }        pushup(now);    }}void Insert(int x){    int l,r;    split(root,x,l,r);    root=Merge(Merge(l,new_node(x)),r);}void Delete(int x){    int l,r,p;    split(root,x,l,p);    split(l,x-1,l,r);    r=Merge(child[r][0],child[r][1]);    root=Merge(Merge(l,r),p);}int Rank(int x){    int l,r;    split(root,x-1,l,r);    int ans=ct[l]+1;    root=Merge(l,r);    return ans;}int Find(int now,int k){    while(1)    {        if(k&lt;=ct[child[now][0]])            now=child[now][0];        else if(k==ct[child[now][0]]+1)            return a[now];        else        {            k-=ct[child[now][0]]+1;            now=child[now][1];        }    }}int pre(int x){    int l,r;    split(root,x-1,l,r);    int ans=Find(l,ct[l]);    root=Merge(l,r);    return ans;}int suc(int x){    int l,r;    split(root,x,l,r);    int ans=Find(r,1);    root=Merge(l,r);    return ans;}int main(){    srand(19260817);    //srand(998244353);    //srand(1e9+7);    //srand((unsigned)time(NULL));    //以上是常用随机种子    scanf(&quot;%d&quot;,&amp;n);    memset(a,-inf,sizeof(a));    for(int i=1;i&lt;=n;i++)    {        int z,x;        scanf(&quot;%d%d&quot;,&amp;z,&amp;x);        switch(z)        {            case 1:Insert(x);break;            case 2:Delete(x);break;            case 3:printf(&quot;%d\n&quot;,Rank(x));break;            case 4:printf(&quot;%d\n&quot;,Find(root,x));break;            case 5:printf(&quot;%d\n&quot;,pre(x));break;            case 6:printf(&quot;%d\n&quot;,suc(x));break;        }    }    return 0;}</code></pre><p>AC记录</p><p><a href="https://www.luogu.org/record/show?rid=6024959" target="_blank" rel="noopener">用时: 316ms / 内存: 3265KB</a></p><p>事实上可以看出Treap比Splay跑的要快一点（说不定是我的Splay太弱了呢？</p><p>然而由于我太蒻了，还是有点懵逼，有dalao能指出我的不足的话感激不尽，也欢迎各位找我讨论</p>]]></content>
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P2900 土地征用 斜率优化dp 题解</title>
      <link href="/2018/07/24/Luogu%20P2900%20%E5%9C%9F%E5%9C%B0%E5%BE%81%E7%94%A8%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%20%E9%A2%98%E8%A7%A3/"/>
      <url>/2018/07/24/Luogu%20P2900%20%E5%9C%9F%E5%9C%B0%E5%BE%81%E7%94%A8%20%E6%96%9C%E7%8E%87%E4%BC%98%E5%8C%96dp%20%E9%A2%98%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>一道裸的斜率优化dp</p><p>首先对于i,j，若存在a[i].len(以下简写为l[i])&gt;=a[j].len&amp;&amp;a[i].wid(以下简写为w[i])&gt;=a[j].wid,则j这块土地是无用的，在预处理时应去掉这些无用的土地。同时在预处理时可以将数据按l降序排列，同时产生的结果是w必然按升序排列（有兴趣的dalao可以自己证明），这样可方便后面的过程。</p><p>然后就是对着数据手推状转方程了（建议先自己推一遍），可知假设用f[i]表示前i块土地的最小价值，则有<strong>f[i]=min{f[j]+l[j+1]w[i]}</strong>。</p><p>然后对数据化简可知假设j比k优，则有<strong>f[j]+l[j+1]w[i]&lt;f[k]+l[k+1]w[i]</strong>,然后就可以得到<strong>(f[k]-f[j])/(l[j+1]-l[k+1])&gt;w[i]</strong></p><p>接着就是一个数形结合的思想了</p><pre><code>一些试题中繁杂的代数关系身后往往隐藏着丰富的几何背景，而借助背景图形的性质，可以使那些原本复杂的数量关系和抽象的概念，显得直观，从而找到设计算法的捷径。——周源</code></pre><p>有兴趣的dalao可以阅读<a href="https://wenku.baidu.com/view/b97cd22d0066f5335a8121a3.html" target="_blank" rel="noopener">浅谈数形结合思想在信息学竞赛中的应用</a></p><p>总之这里将关系式抽象为形如y=kx+b的式子，只要维护组成图形的下凸性就行了，如下图中就是一种要弹出队尾的情况，因为i节点的插入破坏了图形的下凸性<br><img src="http://img.blog.csdn.net/20170122191654269?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvQmlsbF9ZYW5nXzIwMTY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p><p>这里就要用到单调队列了，维护队列中的元素单调（然而我不会，所以请各位懂的大神指点</p><p>不多说见代码</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)#define N 50010using namespace std;long long n,tot,q[N],head=1,tail=1,f[N];struct node{    long long len,wid;};struct node a[N];struct node1{    long long lent,wide;};struct node1 b[N];bool mmp(node xx,node yy){    return xx.len&gt;yy.len||(xx.len==yy.len&amp;&amp;xx.wid&gt;yy.wid);}double slope(int x,int y){    return (double)(f[y]-f[x])/(double)(b[x+1].lent-b[y+1].lent);}//slope 斜率，来自金山词霸int main(){    scanf(&quot;%lld&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)        scanf(&quot;%lld%lld&quot;,&amp;a[i].len,&amp;a[i].wid);    sort(a+1,a+1+n,mmp);    for(int i=1;i&lt;=n;i++)        if(a[i].wid&gt;b[tot].wide)//注意！一定要这样维护b中w的升序排列        {            b[++tot].lent=a[i].len;            b[tot].wide=a[i].wid;        }    for(int i=1;i&lt;=tot;i++)//1~tot动规    {        while(head&lt;tail&amp;&amp;slope(q[head],q[head+1])&lt;=b[i].wide)            head++;//如果队首不是最优，就弹出队首        f[i]=f[q[head]]+b[i].wide*b[q[head]+1].lent;        while(head&lt;tail&amp;&amp;slope(q[tail-1],q[tail])&gt;=slope(q[tail],i))            tail--;//维护一个下凸包        q[++tail]=i;//进队    }    printf(&quot;%lld\n&quot;,f[tot]);//这里也要用tot    return 0;}</code></pre><p>望各位dalao谅解QWQ</p><p>[注] 图片、引文来源<a href="http://blog.csdn.net/bill_yang_2016/article/details/54864284" target="_blank" rel="noopener">[模板] 斜率优化Dp详解</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划，dp </tag>
            
            <tag> 斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P2590 树的统计</title>
      <link href="/2018/07/24/Luogu%20P2590%20%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1/"/>
      <url>/2018/07/24/Luogu%20P2590%20%E6%A0%91%E7%9A%84%E7%BB%9F%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>基础树剖（从<a href="https://www.luogu.org/problemnew/show/P3178" target="_blank" rel="noopener">P3178</a>的代码稍作修改便可A掉<br>这里和3178差别在于线段树的过程不同和一个deep数组，具体看代码</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)//手开O3の日常#define N 100010using namespace std;int n,m,fr,t,a,c,data[N],Size[N],num,p[2*N],fa[N],id,out[2*N],pos[2*N],h[2*N],belong[2*N],b[2*N],nt[2*N],son[N*2],deep[2*N];char s[10];struct node{    int left,right,mx;    long long sum,val;};struct node tree[4*N];//线段树void pushdown(int p){    if(tree[p].val!=0)    {        tree[2*p].val=tree[p].val;        tree[2*p+1].val=tree[p].val;        tree[2*p].sum=(tree[2*p].right-tree[2*p].left+1)*tree[p].val;        tree[2*p+1].sum=(tree[2*p+1].right-tree[2*p+1].left+1)*tree[p].val;        tree[p].val=0;    }}//lazy tag的下放void dfs(int x,int dep){    deep[x]=dep;    Size[x]=1;    int e=p[x];    while(e&gt;0)    {        int k=b[e];        if(fa[x]!=k)        {            fa[k]=x;//记录每个节点的父节点，方便向上跳            dfs(k,dep+1);            if(Size[k]&gt;Size[son[x]])                son[x]=k;//不断更新该节点的重儿子            Size[x]+=Size[k];//更新该节点下方的节点数        }        e=nt[e];    }}//搜索确定每个节点的深度与其下的结点个数void DFS(int x,int bh)//bh为该节点所属重链的编号(编号为该重链起点编号{    id++;    pos[x]=id;//搜索序记录    out[x]=id;//这个数组请忽视(做3178后忘了改QAQ    h[id]=x;//线段树上的位置    int e=p[x];    int k=0;    belong[x]=bh;//记录每个节点所属的重链编号    if(son[x])    {        DFS(son[x],bh);//优先搜索重儿子可得到重链        out[x]=max(out[x],out[son[x]]);    }    e=p[x];    while(e&gt;0)    {        int kk=b[e];        if(fa[x]!=kk&amp;&amp;kk!=son[x])        {            DFS(kk,kk);            out[x]=max(out[x],out[kk]);        }        e=nt[e];    }//搜索轻链}void add(int u,int v){    ++num;    b[num]=v;    nt[num]=p[u];    p[u]=num;}//前向星存图void build(int p,int l,int r){    tree[p].left=l;    tree[p].right=r;    if(l==r)    {        tree[p].sum=data[h[l]];        tree[p].mx=data[h[l]];        return;    }    int mid=(l+r)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);}//建树void change(int p,int l,int r,long long d){    if(tree[p].left==l&amp;&amp;tree[p].right==r)    {        tree[p].sum=(r-l+1)*d;        tree[p].mx=d;        tree[p].val=d;        return;    }    pushdown(p);    int mid=(tree[p].left+tree[p].right)/2;    if(r&lt;=mid)        change(2*p,l,r,d);    else if(l&gt;mid)        change(2*p+1,l,r,d);    else    {        change(2*p,l,mid,d);        change(2*p+1,mid+1,r,d);    }    tree[p].sum=tree[2*p].sum+tree[2*p+1].sum;    tree[p].mx=max(tree[2*p].mx,tree[2*p+1].mx);}//线段树修改操作(注意此处要同时维护区间最大值与区间和long long query(int p,int l,int r){    if(tree[p].left==l&amp;&amp;tree[p].right==r)        return tree[p].sum;    pushdown(p);    int mid=(tree[p].left+tree[p].right)/2;    if(r&lt;=mid)        return query(2*p,l,r);    else if(l&gt;mid)        return query(2*p+1,l,r);    else        return query(2*p,l,mid)+query(2*p+1,mid+1,r);}//查询区间和int Query(int p,int l,int r){    if(tree[p].left==l&amp;&amp;tree[p].right==r)        return tree[p].mx;    pushdown(p);    int mid=(tree[p].left+tree[p].right)/2;    if(r&lt;=mid)        return Query(2*p,l,r);    else if(l&gt;mid)        return Query(2*p+1,l,r);    else        return max(Query(2*p,l,mid),Query(2*p+1,mid+1,r));}//查询区间最大值long long work(int x,int y){    long long sum=0;    while(belong[x]!=belong[y])    {        if(deep[belong[x]]&lt;deep[belong[y]])            swap(x,y);        sum+=query(1,pos[belong[x]],pos[x]);        x=fa[belong[x]];    }    if(deep[x]&gt;deep[y])        swap(x,y);    sum+=query(1,pos[x],pos[y]);    return sum;}//QSUM的操作（解释见下）int Work(int x,int y){    int ans=-214748;    while(belong[x]!=belong[y])    {        if(deep[belong[x]]&lt;deep[belong[y]])            swap(x,y);//比较x和y所属重链起点的深浅，将较浅的向上跳        ans=max(ans,Query(1,pos[belong[x]],pos[x]));        x=fa[belong[x]];    }//如果x与y不在同一重链中，就重复执行操作    if(deep[x]&gt;deep[y])        swap(x,y);    ans=max(ans,Query(1,pos[x],pos[y]));//x与y在同一重链中最后进行一次操作    return ans;}//QMAX的操作int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;n;i++)    {        scanf(&quot;%d%d&quot;,&amp;fr,&amp;t);        add(fr,t);        add(t,fr);    }    for(int i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;data[i]);    dfs(1,1);    DFS(1,1);//先进行搜索确定了线段树上的编号再建树    build(1,1,n);    scanf(&quot;%d&quot;,&amp;m);    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%s&quot;,s);        if(s[1]==&#39;H&#39;)        {            scanf(&quot;%d%d&quot;,&amp;a,&amp;c);            change(1,pos[a],pos[a],c);        }        else if(s[1]==&#39;M&#39;)        {            scanf(&quot;%d%d&quot;,&amp;a,&amp;c);            printf(&quot;%d\n&quot;,Work(a,c));        }        else        {            scanf(&quot;%d%d&quot;,&amp;a,&amp;c);            printf(&quot;%lld\n&quot;,work(a,c));        }    }    return 0;}</code></pre><p>然而跑的很慢<br><a href="https://www.luogu.org/record/show?rid=5654505" target="_blank" rel="noopener">1208ms 7.92Mb</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 树链剖分，树剖 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1120 小木棍【数据加强版】</title>
      <link href="/2018/07/24/Luogu%20P1120%20%E5%B0%8F%E6%9C%A8%E6%A3%8D%E3%80%90%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91/"/>
      <url>/2018/07/24/Luogu%20P1120%20%E5%B0%8F%E6%9C%A8%E6%A3%8D%E3%80%90%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%BC%BA%E7%89%88%E3%80%91/</url>
      <content type="html"><![CDATA[<p>暴力搜索+剪枝</p><p>（这题简直神级剪枝）</p><p>由于200~1000ms实在坑人（实际上最后T的几乎都是500和1000的数据）</p><p>所以卡了我很久……</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 10010using namespace std;int n,len[N],l,cnt,sum;bool used[N];bool mmp(int x,int y){    return x&gt;y;}void dfs(int x,int y,int lent,int goal,int now)//记录当前的这根小木棍{    if(x&gt;sum/goal)    {        printf(&quot;%d&quot;,goal);        exit(0);    }    if(goal-lent&lt;len[cnt])        return;//如果连最小的填进去都会大于当前答案的话就回溯    for(int i=now;i&lt;=cnt;i++)//从当前开始枚举，因为前面的一定被枚举过了，再做就是浪费时间    {        if(!used[i]&amp;&amp;lent+len[i]&lt;=goal)        {            used[i]=true;            lent+=len[i];            if(lent==goal)                dfs(x+1,1,0,goal,1);            else                dfs(x,y+1,lent,goal,i+1);            used[i]=false;            lent-=len[i];            if(lent+len[i]==goal||lent==0)                break;//如果这一组可以凑出却不是正确答案或者第一根都无法满足就直接退出，没必要再去枚举更小的来代替它，因为这一根总是要被用的。            while(len[i]==len[i+1])                i++;//该长度若不可行，则同样长度的也不可行        }    }}int main(){    scanf(&quot;%d&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        scanf(&quot;%d&quot;,&amp;l);        if(l&gt;50)            continue;//一定要优先过滤50+的数据        len[++cnt]=l;        sum+=len[cnt];    }    sort(len+1,len+1+cnt,mmp);//从大到小排序，方便搜索与剪枝    for(int i=len[1];i&lt;=sum/2;i++)        if(sum%i==0)            dfs(1,1,0,i,1);//从小到大枚举答案，遇到一个可直接跳出    printf(&quot;%d&quot;,sum);    return 0;}</code></pre><p>参考了许多题解大佬，从9分到21分到33分到36分到63分到66分到AC……</p><p>而且跑的很慢QwQ</p><p><a href="https://www.luogu.org/record/show?rid=5402366" target="_blank" rel="noopener">1100ms</a></p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
            <tag> 剪枝 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1278 单词游戏</title>
      <link href="/2018/07/24/Luogu%20P1278%20%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/"/>
      <url>/2018/07/24/Luogu%20P1278%20%E5%8D%95%E8%AF%8D%E6%B8%B8%E6%88%8F/</url>
      <content type="html"><![CDATA[<p>这道题<del>据说</del>正解是dp……</p><p>然而我不会……</p><p>所以就写成一个裸的dfs，然后理所当然的T了</p><p><a href="https://www.luogu.org/record/show?rid=5334291" target="_blank" rel="noopener">A7T3</a></p><p>接着就被旁边的dalao嘲笑了</p><p>DTZ大佬的记录</p><p><a href="https://www.luogu.org/record/show?rid=5333743" target="_blank" rel="noopener">0ms</a></p><p>于是我想到了卡时（懒得改记忆化）</p><p>结果莫名就A了……</p><p>具体看代码</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 200using namespace std;char s[N/10][N];int a[N/10][N],n,sum,ans,f[N],tim;bool used[N/10],flag;bool check(char x,int y){    if(x==s[y][0]||x==&#39;\0&#39;)        return true;    return false;}//检查上个单词的最后一位与当前单词的第一位void dfs(int x,char y){    if(clock()-tim&gt;10000)    {        cout&lt;&lt;ans;        exit(0);    }//卡时基本操作，运行到这个时间就输出（虽然听说clock()贼慢，但会省下更多时间）    flag=false;//记录当前点能否搜下去    for(int i=1;i&lt;=n;i++)//枚举当前点    {        if(!used[i]&amp;&amp;check(y,i))        {            flag=true;            int len=strlen(s[i]);            used[i]=true;            sum+=len;            dfs(x+1,s[i][len-1]);//向下搜            sum-=len;            used[i]=false;//回溯        }    }    if(!flag)    {        ans=max(sum,ans);        return;    }//搜不下去就更新答案}int main(){    tim=clock();    scanf(&quot;%d\n&quot;,&amp;n);    for(int i=1;i&lt;=n;i++)    {        if(i!=n)            scanf(&quot;%s\n&quot;,s[i]);        else            scanf(&quot;%s&quot;,s[i]);    }    dfs(1,&#39;\0&#39;);    printf(&quot;%d&quot;,ans);    return 0;}</code></pre><p>这样一看这个也是道假的蓝题……</p><p>卡时有WA的风险，千万别随便学……</p><p>不过这里能A（虽然跑的很慢）</p><p><a href="https://www.luogu.org/record/show?rid=5334979" target="_blank" rel="noopener">136ms</a></p><p>代码有待优化，请各位julao自行修改QwQ。</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
            <tag> 卡时 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1092 虫食算</title>
      <link href="/2018/07/24/Luogu%20P1092%20%E8%99%AB%E9%A3%9F%E7%AE%97/"/>
      <url>/2018/07/24/Luogu%20P1092%20%E8%99%AB%E9%A3%9F%E7%AE%97/</url>
      <content type="html"><![CDATA[<p>由于本人代码不精，连深搜都快忘光了……</p><p>难得写个题，于是来记录一下我的做法。</p><p>首先，这是一道深搜题，但很明显，一个一个字母去搜肯定会炸，怎么办呢？</p><p>我们很容易想到的就是一个一个位置的去搜。</p><p>大家都学过竖式加法，从右往左，从上往下，就按这个顺序一个位置一个位置的搜，很明显就要快一些。</p><p>那么这样就能过了吗？不是，还需要剪枝。</p><p>在这样一个搜索顺序的基础上，搜完一条加一次判定，虽然会用一些时间，但和它省下来的时间比简直不值一提。</p><p>废话不多说，看代码注释</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#pragma GCC optimize(3)//手开O3优化#define N 30using namespace std;bool flag,used[N];int n,a[5][N],num[N];char s[5][N];bool check()//检查是否正确{    int add=0;    for(int i=n;i&gt;=1;i--)    {        int A,B,C;        A=num[a[1][i]],B=num[a[2][i]],C=num[a[3][i]];        if((A+B+add)%n!=C)            return false;        add=(A+B+add)/n;    }    return true;}bool Prune()//剪枝，如果最高位要进位或者无论进不进位都不能使等式成立即舍{    if(num[a[1][1]]+num[a[2][1]]&gt;=n)        return true;    for(int i=n-1;i&gt;=0;i--)    {        int A=num[a[1][i]],B=num[a[2][i]],C=num[a[3][i]];        if(A==-1||B==-1||C==-1)            continue;        if((A+B)%n!=C&amp;&amp;(A+B+1)%n!=C)            return true;    }    return false;}void Print(){    for(int i=1;i&lt;=n;i++)        printf(&quot;%d &quot;,num[i]);    return;}bool Check()//检查是否有字母没赋值{    for(int i=1;i&lt;=n;i++)        if(num[i]==-1)            return false;    return true;}void dfs(int x,int y,int t)//x是列，y是行，t是进位{    if(flag)//标记数组，其实可用exit(0)代替        return;    if(Prune())//开局剪枝        return;    if(Check())    {       if(check())        {            Print();            flag=true;        }        return;    }//如果每个字母都赋值了就进行判定，可以省去一些无用的搜索时间    if(num[a[y][x]]==-1)//如果这一位没赋值    {        for(int i=n-1;i&gt;=0;i--)        {            if(!used[i])            {                if(y!=3)//如果不是第三行                {                    num[a[y][x]]=i;                    used[i]=true;                    dfs(x,y+1,t);//搜索同列下一行                    used[i]=false;                    num[a[y][x]]=-1;                }                else//是第三行                {                    int z=num[a[1][x]]+num[a[2][x]]+t;                    if(z%n!=i)                        continue;                    used[i]=true;                    num[a[y][x]]=i;                    dfs(x-1,1,z/n);//搜索下一列第一行，进位改变                    used[i]=false;                    num[a[y][x]]=-1;                }            }        }    }    else//这一位已被赋值    {        if(y!=3)            dfs(x,y+1,t);        else        {            int z=num[a[1][x]]+num[a[2][x]]+t;            if(Prune())//剪个枝                return;            dfs(x-1,1,z/n);        }    }    return;}void Getid()//将字母转换成数字{    for(int i=1;i&lt;=3;i++)        for(int j=0;j&lt;n;j++)            a[i][j+1]=s[i][j]-&#39;A&#39;+1;    return;}int main(){    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%s%s%s&quot;,s[1],s[2],s[3]);    Getid();    memset(num,-1,sizeof(num));//初值设为-1    dfs(n,1,0);//搜索第n列第1行，进位为0    return 0;}</code></pre><p>注：<br>搜索顺序从0到n-1跑的要慢一些，建议学我，从n-1到0去搜</p><h1 id="从0到n-1"><a href="#从0到n-1" class="headerlink" title="从0到n-1"></a>从0到n-1</h1><p><a href="https://www.luogu.org/record/show?rid=5303961" target="_blank" rel="noopener">844ms</a></p><h1 id="从n-1到0"><a href="#从n-1到0" class="headerlink" title="从n-1到0"></a>从n-1到0</h1><p><a href="https://www.luogu.org/record/show?rid=5304076" target="_blank" rel="noopener">16ms</a></p><p>其实也就是这样不是</p><p>我的代码还有些地方可以优化，我也懒得改了orz（躺</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度优先搜索，DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1047 校门外的树</title>
      <link href="/2018/07/24/Luogu%20P1047%20%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/"/>
      <url>/2018/07/24/Luogu%20P1047%20%E6%A0%A1%E9%97%A8%E5%A4%96%E7%9A%84%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>首先，如题目算法标签所言，线段树<del>（其实也是杂技写法）</del></p><p>不多赘述，建树、修改、查询一气呵成，就算是杂技，也要做杂技中的豪杰（逃）</p><p>代码如下：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 2000010using namespace std;struct node{    int left,right;    long long val,sum;};struct node a[4*N];int data[N],n,m,x,y,b;long long z;void pushup(int p){    a[p].sum=a[2*p].sum+a[2*p+1].sum;}void pushdown(int p){    if(a[p].val!=-1)    {        a[2*p].val=a[p].val;        a[2*p+1].val=a[p].val;        a[2*p].sum=(a[2*p].right-a[2*p].left+1)*a[p].val;        a[2*p+1].sum=(a[2*p+1].right-a[2*p+1].left+1)*a[p].val;        a[p].val=-1;    }}//pushup、pushdown是基本操作，不多讲void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    a[p].val=-1;    if(l==r)    {        a[p].sum=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    a[p].sum=a[2*p].sum+a[2*p+1].sum;}//建树也很简单long long query(int p,int l,int r){    if(a[p].left==l&amp;&amp;a[p].right==r)        return a[p].sum;    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        return query(2*p,l,r);    else if(l&gt;mid)        return query(2*p+1,l,r);    else        return query(2*p,l,mid)+query(2*p+1,mid+1,r);}//查询void change(int p,int l,int r,long long d){    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].sum=(l-r+1)*d;        a[p].val=0;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        change(2*p,l,r,d);    else if(l&gt;mid)        change(2*p+1,l,r,d);    else    {        change(2*p,l,mid,d);        change(2*p+1,mid+1,r,d);    }    pushup(p);}//此函数是与模板唯一的差别，将砍掉的树的值赋为0，这样就只需查询根节点处的区间和了int main(){    cin&gt;&gt;n&gt;&gt;m;    for(int i=1;i&lt;=n+1;i++)        data[i]=1;//将每个位置的初值赋为1，方便查询时只查根节点。值得注意的是，由于这里是算了0这个位置的，所以n、x、y都要相应的加1    build(1,1,n+1);    for(int i=1;i&lt;=m;i++)    {        cin&gt;&gt;x&gt;&gt;y;        change(1,x+1,y+1,0);    }    cout&lt;&lt;query(1,1,n+1);    return 0;}</code></pre><p>比较简单不多说，具体注释看代码</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Luogu P1083 借教室线段树AC</title>
      <link href="/2018/07/18/Luogu%20P1083%20%E5%80%9F%E6%95%99%E5%AE%A4%E7%BA%BF%E6%AE%B5%E6%A0%91AC/"/>
      <url>/2018/07/18/Luogu%20P1083%20%E5%80%9F%E6%95%99%E5%AE%A4%E7%BA%BF%E6%AE%B5%E6%A0%91AC/</url>
      <content type="html"><![CDATA[<p>首先我们说这道题是线段树<del>（其实只是不会二分而已）</del><br>既然是线段树，那么我们首先当然是最简单的建树<br>建树代码如下</p><pre><code class="lang-cpp">void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    if(l==r)    {        a[p].num=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    pushup(p);}</code></pre><p>此处只需要查询区间最小值，所以建树是很基础的，就不多赘述了。<br>接下来是更新</p><pre><code class="lang-cpp">void add(int p,int l,int r,long long d){    if(f==1)        return;    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].val+=d;        a[p].num+=d;        if(a[p].num&lt;0)            f=1;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        add(2*p,l,r,d);    else if(l&gt;mid)        add(2*p+1,l,r,d);    else    {        add(2*p,l,mid,d);        add(2*p+1,mid+1,r,d);    }    pushup(p);}</code></pre><p>值得注意的是此处的标记是为了优化，如果不加就会T掉一个点<br>最后查询的时候只需查询根节点的区间最小值，只需查标记就可以了（但是先要更新）<br>总代码如下：</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define N 1000010using namespace std;struct node{    int left,right;    long long val,num;};struct node a[4*N];int data[N],n,m,x,y,z,b,f;void pushup(int p){    a[p].num=min(a[2*p].num,a[2*p+1].num);}void pushdown(int p){    if(a[p].val!=0)    {        a[2*p].val+=a[p].val;        a[2*p+1].val+=a[p].val;        a[2*p].num+=a[p].val;        a[2*p+1].num+=a[p].val;        a[p].val=0;    }}void build(int p,int l,int r){    a[p].left=l;    a[p].right=r;    if(l==r)    {        a[p].num=data[l];        return;    }    int mid=(a[p].left+a[p].right)/2;    build(2*p,l,mid);    build(2*p+1,mid+1,r);    pushup(p);}void add(int p,int l,int r,long long d){    if(f==1)        return;    if(a[p].left==l&amp;&amp;a[p].right==r)    {        a[p].val+=d;        a[p].num+=d;        if(a[p].num&lt;0)            f=1;        return;    }    pushdown(p);    int mid=(a[p].left+a[p].right)/2;    if(r&lt;=mid)        add(2*p,l,r,d);    else if(l&gt;mid)        add(2*p+1,l,r,d);    else    {        add(2*p,l,mid,d);        add(2*p+1,mid+1,r,d);    }    pushup(p);}int main(){    scanf(&quot;%d %d&quot;,&amp;n,&amp;m);    for(int i=1;i&lt;=n;i++)        scanf(&quot;%d&quot;,&amp;data[i]);    build(1,1,n);    for(int i=1;i&lt;=m;i++)    {        scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z);        add(1,y,z,-x);        if(f==1)        {            printf(&quot;-1\n%d&quot;,i);            return 0;        }    }    printf(&quot;0&quot;);    return 0;}</code></pre><p>虽然说是卡线段树，但其实并不会（虽然3448ms跑的比较慢）<br>总还是可以A</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>题解 Luogu P1205 【[USACO1.2]方块转换 Transformations】</title>
      <link href="/2018/07/18/Luogu%20P1205%20%E3%80%90%5BUSACO1.2%5D%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2%20Transformations%E3%80%91/"/>
      <url>/2018/07/18/Luogu%20P1205%20%E3%80%90%5BUSACO1.2%5D%E6%96%B9%E5%9D%97%E8%BD%AC%E6%8D%A2%20Transformations%E3%80%91/</url>
      <content type="html"><![CDATA[<p>事先说明，发这种代码没有别的意思，纯属好玩<br>这种方法，是谁都会的……暴力……<br>看下来是要有一定毅力的，请谨慎选择是否浏览接下来的代码。</p><pre><code class="lang-cpp">#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#define N 10000000+110using namespace std;int flag,f,g,h,x,y,p,z;int main(){    char a[100][100],b[100][100],c[100][100],d[100][100],e[100][100],w[100][100],r[100][100],t[100][100];    int n;    cin&gt;&gt;n;    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            cin&gt;&gt;a[i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            cin&gt;&gt;d[i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=a[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                flag=1;                break;            }    if(flag==0)    {        cout&lt;&lt;1;        return 0;    }//顺时针旋转90度    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            e[i][j]=a[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            w[i][j]=e[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(w[i][j]!=d[i][j])            {                f=1;                break;            }    if(f==0&amp;&amp;flag==1)    {        cout&lt;&lt;3;        return 0;    }//顺时针旋转180度（因为当时复制错了所以先3再2）    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            r[i][j]=a[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=r[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(t[i][j]!=d[i][j])            {                g=1;                break;            }    if(g==0&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;2;        return 0;    }//逆时针旋转90度    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(t[i][j]!=d[i][j])            {                x=1;                break;            }    if(x==0&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;4;        return 0;    }//镜像翻转    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[j][i];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                y=1;                break;            }    if(y==0&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//5里面分3种情况，4+1，4+2，4+3，此板块接下来的两个板块分别模拟了这三种情况（都看得懂就不详细说明了）    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                z=1;                break;            }    if(z==0&amp;&amp;y==1&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//第二种    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            t[i][j]=a[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            b[i][j]=t[n+1-i][j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            c[i][j]=b[i][n+1-j];    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(c[i][j]!=d[i][j])            {                p=1;                break;            }    if(p==0&amp;&amp;z==1&amp;&amp;y==1&amp;&amp;x==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;5;        return 0;    }//第三种    for(int i=1;i&lt;=n;i++)        for(int j=1;j&lt;=n;j++)            if(a[i][j]!=d[i][j])            {                h=1;                break;            }    if(h==0&amp;&amp;x==1&amp;&amp;y==1&amp;&amp;z==1&amp;&amp;p==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)    {        cout&lt;&lt;6;        return 0;    }//无变换    if(h==1&amp;&amp;x==1&amp;&amp;y==1&amp;&amp;z==1&amp;&amp;p==1&amp;&amp;g==1&amp;&amp;f==1&amp;&amp;flag==1)        cout&lt;&lt;7;//其他    return 0;}</code></pre><p>此题理论上来讲不能随便调换判断的顺序，比如我最初优先判断较为简单的6，结果不能输出最小值……<br>这里调换了2和3，是因为不存在顺时针转90度不可行，而顺时针转180度和逆时针转90度同时可行的情况。<br>所以说这是暴力解法，是谁都会的，只要你有耐心、有毅力，都能做得出来，没什么参考价值【滑稽】</p>]]></content>
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 暴力 </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>可读性极差的A+B</title>
      <link href="/2018/07/18/%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9E%81%E5%B7%AE%E7%9A%84A+B/"/>
      <url>/2018/07/18/%E5%8F%AF%E8%AF%BB%E6%80%A7%E6%9E%81%E5%B7%AE%E7%9A%84A+B/</url>
      <content type="html"><![CDATA[<p>请谨慎选择是否阅读QwQ</p><pre><code class="lang-cpp">#include &lt;bits/stdc++.h&gt;#define ________ return 0#define _____ cin&gt;&gt;#define __________ cout&lt;&lt;#define __ &gt;&gt;#define _ +#define ___ int#define ______ main()using namespace std;___ _________,___________;___ ______{    _____ _________ __ ___________;    __________ _________ _ ___________;    ________;}</code></pre>]]></content>
      
      <categories>
          
          <category> 瞎jb搞 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>博客建成祭</title>
      <link href="/2018/07/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E7%A5%AD/"/>
      <url>/2018/07/18/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%88%90%E5%8A%9F%E7%A5%AD/</url>
      <content type="html"><![CDATA[<p>博客搭建成功啦，纪念一波QwQ</p>]]></content>
      
      <categories>
          
          <category> 祭 </category>
          
      </categories>
      
      
    </entry>
    
  
  
    
    <entry>
      <title>文章分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
